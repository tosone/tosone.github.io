<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tosone&#39;s Blog</title>
    <link>https://tosone.cn/</link>
    <description>Recent content on Tosone&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 26 Apr 2019 10:38:24 +0000</lastBuildDate>
    
        <atom:link href="https://tosone.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CoreOS 初始化配置</title>
      <link>https://tosone.cn/post/coreos-init/</link>
      <pubDate>Fri, 26 Apr 2019 10:38:24 +0000</pubDate>
      
      <guid>https://tosone.cn/post/coreos-init/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;Container Linux (formerly CoreOS Linux) is an open-source lightweight operating system based on the Linux kernel and designed for providing infrastructure to clustered deployments, while focusing on automation, ease of application deployment, security, reliability and scalability. As an operating system, Container Linux provides only the minimal functionality required for deploying applications inside software containers, together with built-in mechanisms for service discovery and configuration sharing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;各个虚拟主机平台上基本都有 CoreOS 系统，但是 Aliyun 上的 ECS 就是有问题的，在用 &lt;code&gt;docker build&lt;/code&gt; 的时候总出问题，在 Docker 的仓库中有这些&lt;a href=&#34;https://github.com/coreos/bugs/issues/2340&#34;&gt;讨论&lt;/a&gt;，最终的解决方法就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# fix wrong driver
echo &#39;{ &amp;quot;storage-driver&amp;quot;: &amp;quot;devicemapper&amp;quot; }&#39; | sudo tee /etc/docker/daemon.json
sudo systemctl restart docker.service

# fix aliyun buggy selinux
sudo sed -i &#39;s/SELINUXTYPE=mcs/SELINUXTYPE=targeted/&#39; /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;升级通道&#34;&gt;升级通道&lt;/h3&gt;

&lt;p&gt;定义了 CoreOS 每次升级的目标版本号。官方提供了三个升级通道，分别为 Alpha、Beta 和 Stable，简单来说就是每个大版本升级的内测、公测和正式发行版。只不过 CoreOS 目前是采用一个不断增加的数字来表示各个版本号，数字越大则相对版本越高。&lt;/p&gt;

&lt;p&gt;各通道发布更新的频率依次为（官方目标数据，实际可能不准时）：
&lt;br/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Alpha：每周星期四发布&lt;/li&gt;
&lt;li&gt;Beta：每两周发布一次&lt;/li&gt;
&lt;li&gt;Stable：每个月发布一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个通道当前的具体版本号可以在&lt;a href=&#34;https://coreos.com/releases/&#34;&gt;这个网页&lt;/a&gt;上查看到。关于升级通道，&lt;a href=&#34;https://coreos.com/os/docs/latest/switching-channels.html&#34;&gt;这篇文档&lt;/a&gt;有更详细的介绍。&lt;/p&gt;

&lt;p&gt;如果你想切换系统所在发布通道的话可以修改文件 &lt;code&gt;/etc/coreos/update.conf&lt;/code&gt; 中的 &lt;code&gt;GROUP=beta&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后重启一下 update-engine 服务 &lt;code&gt;systemctl restart update-engine&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;升级策略&#34;&gt;升级策略&lt;/h3&gt;

&lt;p&gt;关系到系统自动升级后用户是否需要手工重启。它的值可以是 best-effort（默认值）、 etcd-lock、 reboot 和 off。其作用依次解释如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;best-effort：如果Etcd运行正常则相当于 etcd-lock，否则相当于 reboot&lt;/li&gt;
&lt;li&gt;etcd-lock：自动升级后自动重启，使用 LockSmith 服务调度重启过程&lt;/li&gt;
&lt;li&gt;reboot：自动升级后立即自动重启系统&lt;/li&gt;
&lt;li&gt;off：自动升级后等待用户手工重启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;升级通道和升级策略都可以在系统启动时的 cloud-config 中的 coreos.update 中配置，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;coreos:
  update:
    reboot-strategy: best-effort
    group: alpha
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于已经启动的集群，可以在 &lt;code&gt;/etc/coreos/update.conf&lt;/code&gt; 配置文件中修改，其内容格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;GROUP=alpha
REBOOT_STRATEGY=best-effort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改完成后需要重启一下 update-engine 服务：&lt;code&gt;systemctl restart update-engine&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用户手动执行升级一般是没有必要滴。当然如果你非要这么做，也非常简单，命令是 &lt;code&gt;update_engine_client -update&lt;/code&gt;。如果只是想查看一下有没有新版本，可以换个参数 &lt;code&gt;update_engine_client -check_for_update&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;添加账户&#34;&gt;添加账户&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;useradd -U -m tosone -G sudo&lt;/code&gt;，添加一个新的账户，&lt;code&gt;passwd tosone&lt;/code&gt;。
赋予 &lt;code&gt;sudo&lt;/code&gt; 权限，&lt;code&gt;visudo -f /etc/sudoers.d/user1&lt;/code&gt; 添加这样一行： &lt;code&gt;tosone ALL=(ALL) NOPASSWD: ALL&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# su tosone
$ cat /etc/sudoers.d/tosone
cat: /etc/sudoers.d/tosone: Permission denied

$ sudo cat /etc/sudoers.d/tosone
tosone ALL=(ALL) NOPASSWD: ALL
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toolbox&#34;&gt;toolbox&lt;/h3&gt;

&lt;p&gt;toolbox is a small script that launches a container to let you bring in your favorite debugging or admin tools.
There are currently two scripts that live within this repository:
&lt;br/&gt;
- toolbox: designed for Container Linux, uses rkt and systemd-nspawn
- rhcos-toolbox: designed for Red Hat CoreOS, uses podman&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ /usr/bin/toolbox
Spawning container core-fedora-latest on /var/lib/toolbox/core-fedora-latest.
Press ^] three times within 1s to kill container.
[root@localhost ~]# dnf -y install tcpdump
...
[root@localhost ~]# tcpdump -i ens3
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on ens3, link-type EN10MB (Ethernet), capture size 65535 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Automatically enter toolbox on login. Set an &lt;code&gt;/etc/passwd&lt;/code&gt; entry for one of the users to &lt;code&gt;/usr/bin/toolbox&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;useradd bob -m -s /usr/bin/toolbox -U -G sudo,docker,rkt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when SSHing into the system as that user, toolbox will automatically be started:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh bob@hostname.example.com
Container Linux by CoreOS alpha (1284.0.0)
...
Spawning container bob-fedora-latest on /var/lib/toolbox/bob-fedora-latest.
Press ^] three times within 1s to kill container.
[root@localhost ~]# dnf -y install emacs-nox
...
[root@localhost ~]# emacs /media/root/etc/systemd/system/docker.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-docker-compose&#34;&gt;Install docker-compose&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /opt/bin
curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /opt/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Golang 中如何用 CGO 与 C 之间做一个缓存 buffer</title>
      <link>https://tosone.cn/post/golang-cgo-buffer/</link>
      <pubDate>Mon, 05 Nov 2018 20:00:00 +0000</pubDate>
      
      <guid>https://tosone.cn/post/golang-cgo-buffer/</guid>
      
        <description>&lt;p&gt;Golang 和 C 之间如何传递二进制数据呢？&lt;/p&gt;

&lt;p&gt;Golang 是一个不错的语言，尤其是做一个缓存中间层是非常非常容易的。比较常见的场景就是我们在读一个很大很大的文件的时候，我们是做不到一次加载文件到内存的，Golang 可以做到一点一点的将文件读至末尾，慢慢处理完，相信很多语言也很容易做到这个,那如果在处理这个文件的时候项目的主语言是 Golang 而需要用到一些用 C 写好的模块那又该如何呢？如果让一个程序员只用 C 来实现处理一个大文件，那应该也是很容易的。Golang 对 C 的 binding 呢？&lt;/p&gt;

&lt;p&gt;首先，我们先定义一个 C 的数据结构，也是一个很经典的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct buffer_data { // 缓存数据的结构体
  uint8_t *ptr;
  size_t size;
} buffer_data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然是缓存那就应该有一个明确的大小，至少会是一个固定的大小，更复杂的场景可能会根据具体的外部参数造成缓存大小的变化。现在我们只是写一个例子而已，简单至上。然后就需要写一个针对上边的数据结构的初始化函数了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// 初始化传入的 buffer 的内存对象
buffer_data init_buffer() {
  buffer_data buffer_in; // 传入的数据对象
  buffer_in.ptr  = malloc(MAX_BUFFER_SIZE * sizeof(uint8_t));
  buffer_in.size = 0;
  return buffer_in;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码到此为止都很简单，仅仅是申请一些空间给这个缓存，并且缓存大小固定。后边的就稍微有一点点难度了。&lt;/p&gt;

&lt;p&gt;缓存的话，就需要两个函数写入读出来操作。&lt;/p&gt;

&lt;p&gt;读入的操作来说就是将新的数据添加到缓存的尾部，首先看一下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// 从 Golang 中传入数据到 c 的内存中，返回每次读取的数据的数量
// 鉴于内存中不可以缓存过多的数据，也是为了节省内存，那么就需要每次仅将 buffer 填充的一定长度即可
// buffer 数据写入的目的位置
// buf 写入的数据
// buf_size 写入数据的大小
// return 已经写入数据的长度
int buffer_append(buffer_data *buffer, uint8_t *buf, int buf_size) {
  if (buffer-&amp;gt;size == MAX_BUFFER_SIZE) {
    return 0;
  }
  pthread_mutex_lock(&amp;amp;buffer_in_mutex);
  if (MAX_BUFFER_SIZE - buffer-&amp;gt;size &amp;gt; buf_size) {
    memcpy(buffer-&amp;gt;ptr + buffer-&amp;gt;size, buf, buf_size);
    buffer-&amp;gt;size += buf_size;
    pthread_mutex_unlock(&amp;amp;buffer_in_mutex); // 解锁线程
    return buf_size;
  }
  memcpy(buffer-&amp;gt;ptr + buffer-&amp;gt;size, buf, MAX_BUFFER_SIZE - buffer-&amp;gt;size);
  int read     = MAX_BUFFER_SIZE - buffer-&amp;gt;size;
  buffer-&amp;gt;size = MAX_BUFFER_SIZE;
  pthread_mutex_unlock(&amp;amp;buffer_in_mutex); // 解锁线程
  return read;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于写入和读出的操作是针对一个竞态变量的互斥操作，那我们为了防止多线程操作的时候有问题，就需要针对 buffer 操作的时候加上一个线程锁。代码的其他部分就比较容易理解了，仅仅是一些内存复制之类的。&lt;/p&gt;

&lt;p&gt;最后就是那个读出的操作了，读出的操作稍稍有一点点复杂相比写入，常规的做法就是将缓存的头部的数据取出一些，然后将后边的未被读到的数据往前移动，OK，看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// 读出数据
// buffer 数据源
// buf 数据读出之后存储的位置
// buf_size 传入的 buf 的申请的空间的大小
// return 读出的数据的长度
int buffer_read(buffer_data *buffer, uint8_t *buf, int buf_size) {
  if (buf_size == 0) {
    return 0;
  }
  pthread_mutex_lock(&amp;amp;buffer_in_mutex);
  if (buf_size &amp;gt;= buffer-&amp;gt;size) {
    int read = buffer-&amp;gt;size;
    memcpy(buf, buffer-&amp;gt;ptr, buffer-&amp;gt;size);
    buffer-&amp;gt;size = 0;
    pthread_mutex_unlock(&amp;amp;buffer_in_mutex); // 解锁线程
    return read;
  }
  memcpy(buf, buffer-&amp;gt;ptr, buf_size); 
  memmove(buffer-&amp;gt;ptr,buffer-&amp;gt;ptr+buf_size,buffer-&amp;gt;size-buf_size);
  buffer-&amp;gt;size -= buf_size;
  pthread_mutex_unlock(&amp;amp;buffer_in_mutex); // 解锁线程
  return buf_size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到此为止，我们的 C 的部分就完成了，其实这个还是有一点点简陋，真正的应该是 &lt;code&gt;buffer_in&lt;/code&gt; 和 &lt;code&gt;buffer_out&lt;/code&gt; 一个输入的缓存，一个是输出的缓存，中间 C 对输入的缓存做一些处理，比如音频格式转换之类的，然后将数据给到 &lt;code&gt;buffer_out&lt;/code&gt; 中，在 Golang 中接收数据做一些其他处理。&lt;/p&gt;

&lt;p&gt;在这个例子中我们的 Golang 的作用仅仅是将数据一步步放到 buffer 中然后从 buffer 再读出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

// #include &amp;lt;reader.h&amp;gt;
import &amp;quot;C&amp;quot;
import (
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;unsafe&amp;quot;
)

func main() {
    var buffer = C.init_buffer()
    bytes, _ := ioutil.ReadFile(&amp;quot;reader.h.gch&amp;quot;)

    f, _ := os.Create(&amp;quot;reader.out&amp;quot;)
    for len(bytes) != 0 {
        var write = int(C.buffer_append(&amp;amp;buffer, (*C.uchar)(unsafe.Pointer(&amp;amp;bytes[0])), C.int(len(bytes))))
        bytes = bytes[write:]
        for {
            var bytes = make([]byte, 1024)
            var read = int(C.buffer_read(&amp;amp;buffer, (*C.uchar)(unsafe.Pointer(&amp;amp;bytes[0])), C.int(len(bytes))))
            if read == 0 {
                break
            }
            f.Write(bytes[:read])
        }
    }
    f.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，代码到此为止就已经完了，大概的写法就是这样，里边没什么难点，只是有些同学开始做 CGO 的时候不太会写二进制的数据如何在 C 和 Golang 中传递而已。&lt;/p&gt;

&lt;p&gt;完整的项目请查看这里: &lt;a href=&#34;https://github.com/tosone/reader&#34;&gt;https://github.com/tosone/reader&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外要说明的一点是 Golang 和 C 在传递参数的时候是内存拷贝各自管理内存，CGO 底层有做中间内存的处理。所以如果你的程序关于 CGO 那一部分总是出现 Segmentation fault 那就是 C 的内存没有管理好，仔细查查，也有可能是 CGO 底层出了问题，这个概率就比较小了，如果是 Golang 这边出现了问题一般都会有错误的堆栈的打印。这个小例子里边没有考虑太多的内存释放这方面的问题，实际项目中参考这段代码的时候千万注意，坑了别找我。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>CGO 注意事项</title>
      <link>https://tosone.cn/post/cgo-attation/</link>
      <pubDate>Wed, 12 Sep 2018 10:14:28 +0000</pubDate>
      
      <guid>https://tosone.cn/post/cgo-attation/</guid>
      
        <description>&lt;p&gt;Golang 和 C 之间相互调用存在一些局限性。&lt;/p&gt;

&lt;h3 id=&#34;首先不支持可变参数函数&#34;&gt;首先不支持可变参数函数&lt;/h3&gt;

&lt;p&gt;我们知道 C 语言中 stdarg.h 这个头文件提供了可变参数的实现，但是 cgo 中暂未实现对这个特性的支持，这并不意味着 Golang 不支持可变参数，仅仅是 cgo 不支持而已。具体可以看这个 &lt;a href=&#34;https://github.com/golang/go/issues/975&#34;&gt;issue&lt;/a&gt; 和这个 &lt;a href=&#34;https://github.com/golang/go/commit/67d276c57cda9e05faa84c332ba52791d4713f65&#34;&gt;commit&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;{% image fancybox fig-50 clear /assets/images/cgo-attation-1.png &amp;ldquo;CGO variable&amp;rdquo; %}&lt;/p&gt;

&lt;h3 id=&#34;其次不支持带参数的宏定义&#34;&gt;其次不支持带参数的宏定义&lt;/h3&gt;

&lt;p&gt;运行如下两段不同的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

/*
#define test 1
#define ABS(a) ((a) &amp;gt;= 0 ? (a) : (-(a)))
*/
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(C.test)
    fmt.Println(C.ABS(-1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

/*
#define test 1
#define ABS(a) ((a) &amp;gt;= 0 ? (a) : (-(a)))
#define abs ABS(-1)
*/
import &amp;quot;C&amp;quot;

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(C.test)
    fmt.Println(C.abs)
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>系统初始化</title>
      <link>https://tosone.cn/post/linux-init/</link>
      <pubDate>Tue, 11 Sep 2018 12:53:15 +0000</pubDate>
      
      <guid>https://tosone.cn/post/linux-init/</guid>
      
        <description>&lt;p&gt;Ubuntu 和 NodeJs 的环境的初始化。&lt;/p&gt;

&lt;h3 id=&#34;nodejs-初始化&#34;&gt;NodeJs 初始化&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;env NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node nvm install node
nvm alias default v10.6.0
npm config set registry https://registry.npm.taobao.org # set npm registry to taobao
npm install yarn hexo webpack -g # install normal package
yarn config set registry https://registry.npm.taobao.org # set yarn registry to taobao
apm config set registry https://registry.npm.taobao.org # set atom registry to taobao
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;shadowsocks&#34;&gt;shadowsocks&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install shadowsocks-libev
systemctl enable shadowsocks-libev-local@config.service
systemctl start shadowsocks-libev-local@config.service
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ubuntu-初始化&#34;&gt;Ubuntu 初始化&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# variable
atom_version=1.15.0
shadowsocks_ip=45.35.75.57
shadowsocks_port=56002
shadowsocks_pwd=60394675
shadowsocks_method=aes-256-cfb

sudo apt-get install curl
sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;

sudo apt-get autoremove unity-webapps-common firefox
sudo apt-get update
sudo apt-get upgrade
sudo apt-get dist-upgrade
sudo apt-get install redis-server mosquitto python-pip vim zsh nfs-kernel-server git supervisor
sudo pip install --upgrade autopep8 isort shadowsocks

sudo sh -c &amp;quot;echo \&amp;quot;/home/&amp;quot;$USER&amp;quot;/share *(rw,sync)\&amp;quot; &amp;gt;&amp;gt; /etc/exports&amp;quot;
sudo service nfs-kernel-server restart

git config --global credential.helper store
git config --global core.editor vim
ssh-keygen
[[ -f ~/.ssh/config ]] &amp;amp;&amp;amp; rm ~/.ssh/config
echo &amp;quot;Host git.nane.cn KexAlgorithms +diffie-hellman-group1-sha1&amp;quot; &amp;gt;&amp;gt; ~/.ssh/config

gsettings set com.canonical.Unity.Launcher launcher-position Bottom

NVM_DIR=$HOME/.nvm
[[ -d $NVM_DIR ]] &amp;amp;&amp;amp; rm -rf $NVM_DIR
git clone https://github.com/creationix/nvm.git $NVM_DIR
cd $NVM_DIR
git checkout `git describe --abbrev=0 --tags --match &amp;quot;v[0-9]*&amp;quot; origin`
. $NVM_DIR/nvm.sh
echo &amp;quot;export NVM_DIR=\&amp;quot;\$HOME/.nvm\&amp;quot;&amp;quot; &amp;gt;&amp;gt; ~/.zshrc
echo &amp;quot;[ -s \&amp;quot;\$NVM_DIR/nvm.sh\&amp;quot; ] &amp;amp;&amp;amp; . \&amp;quot;\$NVM_DIR/nvm.sh\&amp;quot;&amp;quot; &amp;gt;&amp;gt; ~/.zshrc
source ~/.zshrc
NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node nvm install node
npm config set registry https://registry.npm.taobao.org
npm install yarn -g yarn npm-check-updates eslint
yarn config set registry https://registry.npm.taobao.org

sudo systemctl enable supervisor.service
sudo systemctl restart supervisor.service
sudo sh -c &amp;quot;echo \&amp;quot;[program:shadowsocks]\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;command=sslocal -p &amp;quot;$shadowsocks_port&amp;quot; -s &amp;quot;$shadowsocks_ip&amp;quot; -k &amp;quot;$shadowsocks_pwd&amp;quot; -l 1080 -m &amp;quot;$shadowsocks_method&amp;quot;\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;autostart=true\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;autorestart=true\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;user=root\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;log_stderr=true\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;logfile=/var/log/shadowsocks.log\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;

# sogou=sogou.deb
wget https://npm.taobao.org/mirrors/atom/$atom_version/atom-amd64.deb
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
# wget -O $sogou http://pinyin.sogou.com/linux/download.php?f=linux&amp;amp;bit=64

sudo dpkg -i atom-amd64.deb
sudo dpkg -i google-chrome-stable_current_amd64.deb
# sudo dpkg -i $sogou

sudo apt-get install -f
sudo apt-get autoremove
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;shadowsocks_ip=45.35.75.57
shadowsocks_port=56002
shadowsocks_pwd=60394675
shadowsocks_method=aes-256-cfb
sudo sh -c &amp;quot;echo \&amp;quot;[program:shadowsocks]\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;command=sslocal -p &amp;quot;$shadowsocks_port&amp;quot; -s &amp;quot;$shadowsocks_ip&amp;quot; -k &amp;quot;$shadowsocks_pwd&amp;quot; -l 1080 -m &amp;quot;$shadowsocks_method&amp;quot;\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;autostart=true\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;autorestart=true\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;user=root\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;log_stderr=true\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
sudo sh -c &amp;quot;echo \&amp;quot;logfile=/var/log/shadowsocks.log\&amp;quot; &amp;gt;&amp;gt; /etc/supervisor/conf.d/shadowsocks.conf&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>CGO 入门</title>
      <link>https://tosone.cn/post/cgo/</link>
      <pubDate>Tue, 10 Jul 2018 21:14:28 +0000</pubDate>
      
      <guid>https://tosone.cn/post/cgo/</guid>
      
        <description>&lt;p&gt;Golang 和 C 之间相互调用入门。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;https://github.com/golang/go/wiki/cgo&#34;&gt;https://github.com/golang/go/wiki/cgo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;首先，&lt;a href=&#34;http://golang.org/cmd/cgo&#34;&gt;http://golang.org/cmd/cgo&lt;/a&gt; 是最基础的 cgo 的文档。
关于 cgo 更加详尽的文档在 &lt;a href=&#34;https://blog.golang.org/c-go-cgo&#34;&gt;https://blog.golang.org/c-go-cgo&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;入门&#34;&gt;入门&lt;/h3&gt;

&lt;p&gt;如果一个 Go 的源码文件引用了 &lt;code&gt;&amp;quot;C&amp;quot;&lt;/code&gt; 这个包，那么这就是在用 cgo 了。在整个的编译过程中 Go 将会立即处理位于 &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt; 上边的注释的部分，并且将会和其他的 cgo 的注释 link 到一起，也包括其他所有的 C 文件。&lt;/p&gt;

&lt;p&gt;需要注意的是在 &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt; 和 cgo 注释中间不能有空行。&lt;/p&gt;

&lt;p&gt;想要获取 C 中的变量只需要用到包名为 C 的 Go 内置的依赖。也就是说，如果你想调用 C 的函数 &lt;code&gt;printf()&lt;/code&gt; 在 Go 的代码中，可以这样写 &lt;code&gt;C.printf()&lt;/code&gt;。由于 cgo 还不支持可变参数（见&lt;a href=&#34;https://github.com/golang/go/issues/975&#34;&gt;issue 975&lt;/a&gt;），我们需要将它包裹成另外我们自己的函数 &lt;code&gt;myprint()&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package cgoexample

/*
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void myprint(char* s) {
    printf(&amp;quot;%s\n&amp;quot;, s);
}
*/
import &amp;quot;C&amp;quot;

import &amp;quot;unsafe&amp;quot;

func Example() {
    cs := C.CString(&amp;quot;Hello from stdio\n&amp;quot;)
    C.myprint(cs)
    C.free(unsafe.Pointer(cs))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在-c-中调用-go-方法&#34;&gt;在 C 中调用 Go 方法&lt;/h3&gt;

&lt;p&gt;利用 cgo 在 C 中执行 Go 代码中定义的全局函数或者函数变量都是可行的。&lt;/p&gt;

&lt;h4 id=&#34;全局函数&#34;&gt;全局函数&lt;/h4&gt;

&lt;p&gt;Go 使它的函数在 C 中可见是用的一个特殊的注释 &lt;code&gt;//export&lt;/code&gt;。注意：如果你在用 exports，那么你就不能定义任何 C 的方法在文件头的位置。&lt;/p&gt;

&lt;p&gt;举例说明，有两个文件 foo.c 和 foo.go&lt;/p&gt;

&lt;p&gt;foo.go 的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package gocallback

import &amp;quot;fmt&amp;quot;

/*
#include &amp;lt;stdio.h&amp;gt;
extern void ACFunction();
*/
import &amp;quot;C&amp;quot;

//export AGoFunction
func AGoFunction() {
    fmt.Println(&amp;quot;AGoFunction()&amp;quot;)
}

func Example() {
    C.ACFunction()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foo.c 的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;_cgo_export.h&amp;quot;
void ACFunction() {
    printf(&amp;quot;ACFunction()\n&amp;quot;);
    AGoFunction();
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;函数变量&#34;&gt;函数变量&lt;/h4&gt;

&lt;p&gt;下边的代码展示了一个 C 中执行 Go 代码中定义的回调函数。由于指针传递规则，Go 代码不能直接传递一个函数变量到 C 中。我们需要用间接的方式来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package gocallback

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
)

/*
extern void go_callback_int(int foo, int p1);

// normally you will have to define function or variables
// in another separate C file to avoid the multiple definition
// errors, however, using &amp;quot;static inline&amp;quot; is a nice workaround
// for simple functions like this one.
static inline void CallMyFunction(int foo) {
    go_callback_int(foo, 5);
}
*/
import &amp;quot;C&amp;quot;

//export go_callback_int
func go_callback_int(foo C.int, p1 C.int) {
    fn := lookup(int(foo))
    fn(p1)
}

func MyCallback(x C.int) {
    fmt.Println(&amp;quot;callback with&amp;quot;, x)
}

func Example() {
    i := register(MyCallback)
    C.CallMyFunction(C.int(i))
    unregister(i)
}

var mu sync.Mutex
var index int
var fns = make(map[int]func(C.int))

func register(fn func(C.int)) int {
    mu.Lock()
    defer mu.Unlock()
    index++
    for fns[index] != nil {
        index++
    }
    fns[index] = fn
    return index
}

func lookup(i int) func(C.int) {
    mu.Lock()
    defer mu.Unlock()
    return fns[i]
}

func unregister(i int) {
    mu.Lock()
    defer mu.Unlock()
    delete(fns, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following code shows an example of invoking a Go callback from C code. Because of the pointer passing rules Go code can not pass a function value directly to C. Instead it is necessary to use an indirection. This example uses a registry with a mutex, but there are many other ways to map from a value that can be passed to C to a Go function.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>[转载] 那些 C 语言缺失的，我在 Rust 里找到了</title>
      <link>https://tosone.cn/post/missing-in-c-but-found-in-rust/</link>
      <pubDate>Sun, 11 Mar 2018 20:14:28 +0000</pubDate>
      
      <guid>https://tosone.cn/post/missing-in-c-but-found-in-rust/</guid>
      
        <description>&lt;p&gt;我大概在 24 年前就爱上了 C 语言。当时，我通过一本西班牙语版的 &amp;ldquo;The C Programming Language&amp;rdquo;（第二版，作者是 Brian Kernighan 和 Dennis Ritchie，所以有时候也用 K&amp;amp;R 来称呼这本书）来学习 C 语言。在这之前，我用过 Turbo Pascal，它也有指针，也需要手动管理内存，而 C 语言在当时是新生事物，但十分强大。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;http://www.infoq.com/cn/articles/rust-things-i-miss-in-c&#34;&gt;http://www.infoq.com/cn/articles/rust-things-i-miss-in-c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;英文原文链接：&lt;a href=&#34;https://people.gnome.org/~federico/blog/rust-things-i-miss-in-c.html&#34;&gt;https://people.gnome.org/~federico/blog/rust-things-i-miss-in-c.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;c-语言挽歌&#34;&gt;C 语言挽歌&lt;/h3&gt;

&lt;p&gt;我大概在 24 年前就爱上了 C 语言。当时，我通过一本西班牙语版的 &amp;ldquo;The C Programming Language&amp;rdquo;（第二版，作者是 Brian Kernighan 和 Dennis Ritchie，所以有时候也用 K&amp;amp;R 来称呼这本书）来学习 C 语言。在这之前，我用过 Turbo Pascal，它也有指针，也需要手动管理内存，而 C 语言在当时是新生事物，但十分强大。&lt;/p&gt;

&lt;p&gt;K&amp;amp;R 因其独特的文风和简洁明了的代码风格而闻名。它甚至还教你如何自己实现简单的 &lt;code&gt;malloc()&lt;/code&gt; 和 &lt;code&gt;free()&lt;/code&gt; 函数，这实在太有意思了。而且，这门语言本身的一些特性也可以通过自身来实现。&lt;/p&gt;

&lt;p&gt;在接下来的几年，我一直使用 C 语言。它是一门轻巧的编程语言，使用差不多 2 万行代码实现了 Unix 内核。&lt;/p&gt;

&lt;p&gt;GIMP 和 GTK+ 让我学会了如何使用 C 语言来实现面向对象编程，GNOME 让我学会了如何使用 C 语言维护大型的软件项目。一个 2 万行代码的项目，一个人花上几周就可以完全读懂。&lt;/p&gt;

&lt;p&gt;但现在的代码库规模已经不可同日而语，我们的软件对编程语言的标准库有了更高的期望。&lt;/p&gt;

&lt;h3 id=&#34;c-语言的一些好的体验&#34;&gt;C 语言的一些好的体验&lt;/h3&gt;

&lt;p&gt;第一次通过阅读 POV-Ray 源代码学会如何在 C 语言中实现面向对象编程。&lt;/p&gt;

&lt;p&gt;通过阅读 GTK+ 源代码了解 C 语言代码的清晰、干净和可维护性。&lt;/p&gt;

&lt;p&gt;通过阅读 SIOD 和 Guile 的源代码，知道如何使用 C 语言实现 Scheme 解析器。&lt;/p&gt;

&lt;p&gt;使用 C 语言写出 GNOME Eye 的初始版本，并对 MicroTile 渲染进行调优。&lt;/p&gt;

&lt;h3 id=&#34;c-语言的一些不好的体验&#34;&gt;C 语言的一些不好的体验&lt;/h3&gt;

&lt;p&gt;在 Evolution 团队时，很多东西老是崩溃。那个时候还没有 Valgrind，为了得到 Purify 这个软件，需要购买一台 Solaris 机器。&lt;/p&gt;

&lt;p&gt;调试 gnome-vfs 线程死锁问题。&lt;/p&gt;

&lt;p&gt;调试 Mesa，却无果。&lt;/p&gt;

&lt;p&gt;接手 Nautilus-share 的初始版本，却发现代码里面居然没有使用 &lt;code&gt;free()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;想要重构代码，却不知道该如何管理好内存。&lt;/p&gt;

&lt;p&gt;想要打包代码，却发现到处是全局变量，而且没有静态函数。&lt;/p&gt;

&lt;p&gt;但不管怎样，还是来说说那些 Rust 里有但 C 语言里没有的东西吧。&lt;/p&gt;

&lt;h3 id=&#34;自动资源管理&#34;&gt;自动资源管理&lt;/h3&gt;

&lt;p&gt;我读过的第一篇关于 Rust 的文章是 &amp;ldquo;&lt;a href=&#34;http://blog.skylight.io/rust-means-never-having-to-close-a-socket/&#34;&gt;Rust means never having to close a socket&lt;/a&gt;&amp;ldquo;。Rust 从 C++ 那里借鉴了一些想法，如 RAII（Resource Acquisition Is Initialization，资源获取即初始化）和智能指针，并加入了值的单一所有权原则，还提供了自动化的决策性资源管理机制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动化：不需要手动调用 &lt;code&gt;free()&lt;/code&gt;。内存使用完后会自动释放，文件使用完后会自动关闭，互斥锁在作用域之外会自动释放。如果要封装外部资源，基本上只要实现 Drop 这个 trait 就可以了。封装过的资源就像是编程语言的一部分，因为你不需要去管理它的生命周期。&lt;/li&gt;
&lt;li&gt;决策性：资源被创建（内存分配、初始化、打开文件等），然后在作用域之外被销毁。根本不存在垃圾收集这回事：代码执行完就都结束了。程序数据的生命周期看起来就像是函数调用树。
如果在写代码时老是忘记调用这些方法（free/close/destroy），或者发现以前写的代码已经忘记调用，甚至错误地调用，那么以后我再也不想使用这些方法了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;泛型&#34;&gt;泛型&lt;/h3&gt;

&lt;p&gt;Vec&lt;T&gt; 真的就是元素 T 的 vector，而不只是对象指针的数组。在经过编译之后，它只能用来存放类型 T 的对象。&lt;/p&gt;

&lt;p&gt;在 C 语言里需要些很多代码才能实现类似的功能，所以我不想再这么干了。&lt;/p&gt;

&lt;h3 id=&#34;trait-不只是-interface&#34;&gt;trait 不只是 interface&lt;/h3&gt;

&lt;p&gt;Rust 并不是一门类似 Java 那样的面向对象编程语言，它有 trait，看起来就像是 Java 里的 interface 可以用来实现动态绑定。如果一个对象实现了 Drawable，那么就可以肯定该对象带有 &lt;code&gt;draw()&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;不过不管怎样，trait 的威力可不止这些。&lt;/p&gt;

&lt;h3 id=&#34;关联类型&#34;&gt;关联类型&lt;/h3&gt;

&lt;p&gt;trait 里可以包含关联类型，以 Rust 的 Iterator 这个 trait 为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Iterator {
  type Item;
  fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，在实现 Iterator 时，必须同时指定一个 Item 类型。在调用 &lt;code&gt;next()&lt;/code&gt; 方法时，如果还有更多元素，会得到一个 Some（用户定义的元素类型）。如果元素迭代完毕，会返回 None。&lt;/p&gt;

&lt;p&gt;关联类型可以引用其他 trait。&lt;/p&gt;

&lt;p&gt;例如，在 Rust 里，for 循环可以用于遍历任何一个实现了 IntoIterator 的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait IntoIterator {
  /// 被遍历元素的类型
  type Item;
  type IntoIter: Iterator&amp;lt;Item=Self::Item&amp;gt;;
  fn into_iter(self) -&amp;gt; Self::IntoIter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在实现这个 trait 时，必须同时提供 Item 类型和 IntoIter 类型，IntoIter 必须实现 Iterator，用于维护迭代器状态。&lt;/p&gt;

&lt;p&gt;通过这种方式就可以建立起类型网络，类型之间相互引用。&lt;/p&gt;

&lt;h3 id=&#34;字符串切割&#34;&gt;字符串切割&lt;/h3&gt;

&lt;p&gt;我之前发表了一篇有关 C 语言缺少字符串切割特性的&lt;a href=&#34;https://people.gnome.org/~federico/blog/rant-on-string-slices.html&#34;&gt;文章&lt;/a&gt;，解释了 C 语言的这个痛点。&lt;/p&gt;

&lt;h3 id=&#34;依赖管理&#34;&gt;依赖管理&lt;/h3&gt;

&lt;p&gt;以前实现依赖管理需要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;手动调用或通过自动化工具宏来调用 pkg-config。&lt;/li&gt;
&lt;li&gt;指定头文件和库文件路径。&lt;/li&gt;
&lt;li&gt;基本上需要人为确保安装了正确版本的库文件。&lt;/li&gt;
&lt;li&gt;而在 Rust 里，只需要编写一个 Cargo.toml 文件，然后在文件里指明依赖库的版本。这些依赖库会被自动下载下来，或者从某个指定的地方获取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;p&gt;C 语言的单元测试非常困难，原因如下：&lt;/p&gt;

&lt;p&gt;内部函数通常都是静态的。也就是说，它们无法被外部文件调用。测试程序需要使用 &lt;code&gt;#include&lt;/code&gt; 指令把源文件包含进来，或者使用 &lt;code&gt;#ifdefs&lt;/code&gt; 在测试过程中移除这些静态函数。需要编写 Makefile 文件将测试程序链接到其中的部分依赖库或部分代码。
需要使用测试框架，并把测试用例注册到框架上，还要学会如何使用这些框架。而在 Rust 里，可以在任何地方写这样的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[test]
fn test_that_foo_works() {
  assert!(foo() == expected_result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 cargo test 运行单元测试。这些代码只会被链接到测试文件中，不需要手动编译任何东西，不需要编写 Makefile 文件或抽取内部函数用于测试。&lt;/p&gt;

&lt;p&gt;对我来说，这个功能简直就是杀手锏。&lt;/p&gt;

&lt;h3 id=&#34;包含测试的文档&#34;&gt;包含测试的文档&lt;/h3&gt;

&lt;p&gt;在 Rust 中，可以将使用 Markdown 语法编写的注释生成文档。注释里的测试代码会被作为测试用例执行。也就是说，你可以在解释如何使用一个函数的同时对它进行单元测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;/// Multiples the specified number by two
///
/// ```
/// assert_eq!(multiply_by_two(5), 10);
/// ```
fn multiply_by_two(x: i32) -&amp;gt; i32 {
  x * 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释中的示例代码被作为测试用例执行，以确保文档与实际代码保持同步。&lt;/p&gt;

&lt;h3 id=&#34;卫生宏-hygienic-macro&#34;&gt;卫生宏（Hygienic Macro）&lt;/h3&gt;

&lt;p&gt;Rust 的卫生宏避免了 C 语言宏可能存在的问题，比如宏中的一些东西会掩盖掉代码里的标识符。Rust 并不要求宏中所有的符号都必须使用括号，比如 &lt;code&gt;max(5 + 3, 4)&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;没有自动转型&#34;&gt;没有自动转型&lt;/h3&gt;

&lt;p&gt;在 C 语言里，很多 bug 都是因为在无意中将 int 转成 short 或 char 而导致，而在 Rust 里就不会出现这种情况，因为它要求显示转型。&lt;/p&gt;

&lt;h3 id=&#34;不会出现整型溢出&#34;&gt;不会出现整型溢出&lt;/h3&gt;

&lt;p&gt;这个就不用再多作解释了。&lt;/p&gt;

&lt;p&gt;在安全模式下，Rust 里几乎不存在未定义的行为
在 Rust 的“安全”模式下编写的代码（unsafe{} 代码块之外的代码）如果出现了未定义行为，可以直接把它当成是一个 bug 来处理。比如，将一个负整数右移，这样做是完全可以的。&lt;/p&gt;

&lt;h3 id=&#34;模式匹配&#34;&gt;模式匹配&lt;/h3&gt;

&lt;p&gt;在对一个枚举类型进行 switch 操作时，如果没有处理所有的值，gcc 编译器就会给出警告。&lt;/p&gt;

&lt;p&gt;Rust 提供了模式匹配，可以在 match 表达式里处理枚举类型，并从单个函数返回多个值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl f64 {
  pub fn sin_cos(self) -&amp;gt; (f64, f64);
}

let angle: f64 = 42.0;
let (sin_angle, cos_angle) = angle.sin_cos();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;match 表达式也可以用在字符串上。是的，字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let color = &amp;quot;green&amp;quot;;

match color {
  &amp;quot;red&amp;quot;  =&amp;gt; println!(&amp;quot;it&#39;s red&amp;quot;),
  &amp;quot;green&amp;quot; =&amp;gt; println!(&amp;quot;it&#39;s green&amp;quot;),
  _    =&amp;gt; println!(&amp;quot;it&#39;s something else&amp;quot;),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你是不是很难猜出下面这个函数是干什么用的？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;my_func(true, false, false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但如果在函数的参数上使用模式匹配，那么事情就会变得不一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct Fubarize(pub bool);
pub struct Frobnify(pub bool);
pub struct Bazificate(pub bool);

fn my_func(Fubarize(fub): Fubarize,
      Frobnify(frob): Frobnify,
      Bazificate(baz): Bazificate) {
  if fub {
    ...;
  }

  if frob &amp;amp;&amp;amp; baz {
    ...;
  }
}

...

my_func(Fubarize(true), Frobnify(false), Bazificate(true));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;标准的错误处理&#34;&gt;标准的错误处理&lt;/h3&gt;

&lt;p&gt;在 Rust 里，不再只是简单地返回一个布尔值表示出错与否，也不再简单粗暴地忽略错误，也不再通过非本地跳转来处理异常。&lt;/p&gt;

&lt;h3 id=&#34;derive-debug&#34;&gt;#[derive(Debug)]&lt;/h3&gt;

&lt;p&gt;在创建新类型时（比如创建一个包含大量字段的 struct），可以使用 &lt;code&gt;#[derive(Debug)]&lt;/code&gt;，Rust 会自动打印该类型的内容用于调试，不需要再手动编写函数去获取类型的信息。&lt;/p&gt;

&lt;h3 id=&#34;闭包&#34;&gt;闭包&lt;/h3&gt;

&lt;p&gt;不再需要使用函数指针了。&lt;/p&gt;

&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;

&lt;p&gt;在多线程环境里，Rust 的并发控制机制可以防止出现数据竟态条件。我想，对于那些经常写多线程并发代码的人来说，这会是个好消息。&lt;/p&gt;

&lt;p&gt;C 语言是一门古老的语言，用它来编写单处理器的 Unix 内核或许是个不错的选择，但对于现今的软件来说，它算不上好语言。&lt;/p&gt;

&lt;p&gt;Rust 有一定的学习曲线，但我觉得完全值得一学。它之所以不好学，是因为它要求开发者对自己所写的代码必须有充分的了解。我想，Rust 是一门这样的语言：它可以让你变成更好的开发者，而且它会成为你解决问题的利器。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>cgo is not go</title>
      <link>https://tosone.cn/post/cgo-is-not-go/</link>
      <pubDate>Sat, 10 Mar 2018 21:14:28 +0000</pubDate>
      
      <guid>https://tosone.cn/post/cgo-is-not-go/</guid>
      
        <description>&lt;p&gt;Some people, when confronted with a problem, think &amp;ldquo;I know, I’ll use cgo.&amp;rdquo; Now they have two problems.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;https://dave.cheney.net/2016/01/18/cgo-is-not-go&#34;&gt;https://dave.cheney.net/2016/01/18/cgo-is-not-go&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Recently the use of cgo came up on the Gophers’ slack channel and I voiced my concerns that using cgo, especially on a project that is intended to showcase Go inside an organisation was a bad idea. I’ve said this a number of times, and people are probably sick of hearing my spiel, so I figured that I’d write it down and be done with it.&lt;/p&gt;

&lt;p&gt;cgo is an amazing technology which allows Go programs to interoperate with C libraries. It’s a tremendously useful feature without which Go would not be in the position it is today. cgo is key to ability to run Go programs on Android and iOS.&lt;/p&gt;

&lt;p&gt;However, and to be clear these are my opinions, I am not speaking for anyone else, I think cgo is overused in Go projects. I believe that when faced with reimplementing a large piece of C code in Go, programmers choose instead to use cgo to wrap the library, believing that it is a more tractable problem. I believe this is a false economy.&lt;/p&gt;

&lt;p&gt;Obviously, there are some cases where cgo is unavoidable, most notably where you have to interoperate with a graphics driver or windowing system that is only available as a binary blob. But those cases where cgo’s use justifies its trade-offs are fewer and further between than many are prepared to admit.&lt;/p&gt;

&lt;p&gt;Here is an incomplete list of trade-offs you make, possibly without realising them, when you base your Go project on a cgo library.&lt;/p&gt;

&lt;h3 id=&#34;slower-build-times&#34;&gt;Slower build times&lt;/h3&gt;

&lt;p&gt;When you import &amp;ldquo;C&amp;rdquo; in your Go package, go build has to do a lot more work to build your code. Building your package is no longer simply passing a list of all the .go files in scope to a single invocation of go tool compile, instead:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The cgo tool needs to be invoked to generate the C to Go and Go to C thunks and stubs.&lt;/li&gt;
&lt;li&gt;Your system C compiler has to be invoked for every C file in the package.&lt;/li&gt;
&lt;li&gt;The individual compilation units are combined together into a single .o file.&lt;/li&gt;
&lt;li&gt;The resulting .o file take a trip through the system linker for fix-ups against shared objects they reference.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All this work happens every time you compile or test your package, which is constantly, if you’re actively working in that package. The Go tool parallelises some of this work where possible, but your packages’ compile time just grew to include a full rebuild of all that C code.&lt;/p&gt;

&lt;p&gt;It’s possible to work around this by pushing the cgo shims out into their own package, avoiding the compile time hit, but now you’ve had to restructure your application to work around a problem that you didn’t have before you started to use cgo.&lt;/p&gt;

&lt;p&gt;Oh, and you have to debug C compilation failures on the various platforms your package supports.&lt;/p&gt;

&lt;h3 id=&#34;complicated-builds&#34;&gt;Complicated builds&lt;/h3&gt;

&lt;p&gt;One of the goals of Go was to produce a language who’s build process was self describing; the source of your program contains enough information for a tool to build the project. This is not to say that using a Makefile to automate your build workflow is bad, but before cgo was introduced into a project, you may not have needed anything but the go tool to build and test. Afterwards, to set all the environment variables, keep track of shared objects and header files that may be installed in weird places, now you do.&lt;/p&gt;

&lt;p&gt;Keep in mind that Go supports platforms that don’t ship with make out of the box, so you’ll have to dedicate some time to coming up with a solution for your Windows users.&lt;/p&gt;

&lt;p&gt;Oh, and now your users have to have a C compiler installed, not just a Go compiler. They also have to install the C libraries your project depends on, so you’ll be taking on that support cost as well.&lt;/p&gt;

&lt;h3 id=&#34;cross-compilation-goes-out-the-window&#34;&gt;Cross compilation goes out the window&lt;/h3&gt;

&lt;p&gt;Go’s support for cross compilation is best in class. As of &lt;a href=&#34;http://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5&#34;&gt;Go 1.5 you can cross compile&lt;/a&gt; from any supported platform to any other platform with the official installer available on the Go project website.&lt;/p&gt;

&lt;p&gt;By default cgo is disabled when cross compiling. Normally this isn’t a problem if your project is pure Go. When you mix in dependencies on C libraries, you either have to give up the option to cross compile your product, or you have to invest time in finding and maintaining cross compilation C toolchains for all your targets.&lt;/p&gt;

&lt;p&gt;Maybe if you work on a product that only communicates with clients over TCP sockets and you intend to run it in a SaaS model it’s reasonable to say that you don’t care about cross compilation. However, if you’re making a product which others will use, possibly integrated into their products, maybe it’s a monitoring solution, maybe it’s a client for your SaaS service, then you’ve locked them out of being able to easily cross compile.&lt;/p&gt;

&lt;p&gt;The number of platforms that Go supports continues to grow. Go 1.5 added support for 64 bit ARM and PowerPC. Go 1.6 adds support for 64 bit MIPS, and IBM’s s390 architecture is touted for Go 1.7. RISC-V is in the pipeline. If your product relies on a C library, not only do you have the all problems of cross compilation described above, you also have to make sure the C code you depend on works reliably on the new platforms Go is supporting — and you have to do that with the limited debuggability a C/Go hybrid affords you. Which brings me to my next point.&lt;/p&gt;

&lt;h3 id=&#34;you-lose-access-to-all-your-tools&#34;&gt;You lose access to all your tools&lt;/h3&gt;

&lt;p&gt;Go has great tools; we have the race detector, pprof for profiling code, coverage, fuzz testing, and source code analysis tools. None of those work across the cgo blood/brain barrier.&lt;/p&gt;

&lt;p&gt;Conversely excellent tools like valgrind don’t understand Go’s calling conventions or stack layout.  On that point, Ian Lance Taylor’s work to integrate clang’s memory sanitiser to debug dangling pointers on the C side will be of benefit for cgo users in Go 1.6.&lt;/p&gt;

&lt;p&gt;Combing Go code and C code results in the intersection of both worlds, not the union; the memory safety of C, and the debuggability of a Go program.&lt;/p&gt;

&lt;h3 id=&#34;performance-will-always-be-an-issue&#34;&gt;Performance will always be an issue&lt;/h3&gt;

&lt;p&gt;C code and Go code live in two different universes, cgo traverses the boundary between them. This transition is not free and depending on where it exists in your code, the cost could be inconsequential, or substantial.&lt;/p&gt;

&lt;p&gt;C doesn’t know anything about Go’s calling convention or growable stacks, so a call down to C code must record all the details of the goroutine stack, switch to the C stack, and run C code which has no knowledge of how it was invoked, or the larger Go runtime in charge of the program.&lt;/p&gt;

&lt;p&gt;To be fair, Go doesn’t know anything about C’s world either. This is why the rules for passing data between the two have become more onerous over time as the compiler becomes better at spotting stack data that is no longer considered live, and the garbage collector becomes better at doing the same for the heap.&lt;/p&gt;

&lt;p&gt;If there is a fault while in the C universe, the Go code has to recover enough state to at least print a stack trace and exit the program cleanly, rather than barfing up a core file.&lt;/p&gt;

&lt;p&gt;Managing this transition across call stacks, especially where signals, threads and callbacks are involved is non trivial, and again Ian Lance Taylor has done a huge amount of work in Go 1.6 to improve the interoperability of signal handling with C.&lt;/p&gt;

&lt;p&gt;The take away is that the transition between the C and Go world is non trivial, and it will never be free from overhead.&lt;/p&gt;

&lt;h3 id=&#34;c-calls-the-shots-not-your-code&#34;&gt;C calls the shots, not your code&lt;/h3&gt;

&lt;p&gt;It doesn’t matter which language you’re writing bindings or wrapping C code with; Python, Java with JNI, some language using libFFI, or Go via cgo; it’s C’s world, you’re just living in it.&lt;/p&gt;

&lt;p&gt;Go code and C code have to agree on how resources like address space, signal handlers, and thread TLS slots are to be shared — and when I say agree, I actually mean Go has to work around the C code’s assumption. C code that can assume it always runs on one thread, or blithely be unprepared to work in a multi threaded environment at all.&lt;/p&gt;

&lt;p&gt;You’re not writing a Go program that uses some logic from a C library, instead you’re writing a Go program that has to coexist with a belligerent piece of C code that is hard to replace, has the upper hand negotiations, and doesn’t care about your problems.&lt;/p&gt;

&lt;h3 id=&#34;deployment-gets-more-complicated&#34;&gt;Deployment gets more complicated&lt;/h3&gt;

&lt;p&gt;Any presentation on Go to a general audience will contain at least one slide with these words:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Single, static binary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is Go’s ace in the hole that has lead it to become a poster child of the movement away from virtual machines and managed runtimes. Using cgo, you give that up.&lt;/p&gt;

&lt;p&gt;Depending on your environment, it’s probably possible to build your Go project into a deb or rpm, and assuming your other dependencies are also packaged, add them as an install dependency and push the problem off the operating system’s package manager. But that’s several significant changes to a build and deploy process that was previously as straight forward as go build &amp;amp;&amp;amp; scp.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/&#34;&gt;It is possible to compile a Go program entirely statically&lt;/a&gt;, but it is by no means simple and shows that the ramifications of including cgo in your project will ripple through your entire build and deploy life cycle.&lt;/p&gt;

&lt;h3 id=&#34;choose-wisely&#34;&gt;Choose wisely&lt;/h3&gt;

&lt;p&gt;To be clear, I am not saying that you should not use cgo. But before you make that Faustian bargain, please consider carefully the qualities of Go that you’ll be giving up in return.&lt;/p&gt;

&lt;h3 id=&#34;related-posts&#34;&gt;Related Posts:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2013/07/09/an-introduction-to-cross-compilation-with-go-1-1&#34;&gt;An introduction to cross compilation with Go 1.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5&#34;&gt;Cross compilation with Go 1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5&#34;&gt;Cross compilation just got a whole lot better in Go 1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2012/09/08/an-introduction-to-cross-compilation-with-go&#34;&gt;An introduction to cross compilation with Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Golang 获取 goroutine id 完全指南</title>
      <link>https://tosone.cn/post/golang-get-goroutine-id/</link>
      <pubDate>Fri, 09 Mar 2018 21:14:28 +0000</pubDate>
      
      <guid>https://tosone.cn/post/golang-get-goroutine-id/</guid>
      
        <description>&lt;p&gt;在 Golang 中，每个 goroutine 协程都有一个 goroutine id (goid)，该goid没有向应用层暴露。但是，在很多场景下，开发者又希望使用 goid 作为唯一标识，将一个 goroutine 中的函数层级调用串联起来。比如，希望在一个 http handler 中将这个请求的每行日志都加上对应的 goid 以便于对这个请求处理过程进行跟踪和分析。&lt;/p&gt;

&lt;p&gt;关于是否应该将 goid 暴露给应用层已经争论多年。基本上，Golang 的开发者都一致认为不应该暴露 goid（&lt;a href=&#34;https://github.com/golang/go/issues/22770&#34;&gt;faq: document why there is no way to get a goroutine ID&lt;/a&gt;），主要有以下几点理由：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;goroutine 设计理念是轻量，鼓励开发者使用多 goroutine 进行开发，不希望开发者通过 goid 做 goroutine local storage 或 thread local storage（TLS）的事情；&lt;/li&gt;
&lt;li&gt;Golang 开发者Brad认为 TLS 在 C/C++ 实践中也问题多多，比如一些使用TLS的库，thread 状态非常容易被非期望线程修改，导致crash.&lt;/li&gt;
&lt;li&gt;goroutine 并不等价于thread, 开发者可以通过syscall 获取 thread id，因此根本不需要暴露 goid.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官方也一直推荐使用context作为上下文关联的最佳实践。如果你还是想获取 goid，下面是我整理的目前已知的所有获取它的方式，希望你想清楚了再使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过 stack 信息获取 goroutine id.&lt;/li&gt;
&lt;li&gt;通过修改源代码获取 goroutine id.&lt;/li&gt;
&lt;li&gt;通过 CGo 获取 goroutine id.&lt;/li&gt;
&lt;li&gt;通过汇编获取 goroutine id.&lt;/li&gt;
&lt;li&gt;通过汇编获取伪 goroutine id.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在开始介绍各种方法前，先看一下定义在 &lt;code&gt;src/runtime/runtime2.go&lt;/code&gt; 中保存 goroutine 状态的g结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type g struct {
    // Stack parameters.
    // stack describes the actual stack memory: [stack.lo, stack.hi).
    // stackguard0 is the stack pointer compared in the Go stack growth prologue.
    // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
    // stackguard1 is the stack pointer compared in the C stack growth prologue.
    // It is stack.lo+StackGuard on g0 and gsignal stacks.
    // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
    stack       stack   // offset known to runtime/cgo
    stackguard0 uintptr // offset known to liblink
    stackguard1 uintptr // offset known to liblink

    _panic         *_panic // innermost panic - offset known to liblink
    _defer         *_defer // innermost defer
    m              *m      // current m; offset known to arm liblink
    sched          gobuf
    syscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc
    syscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc
    stktopsp       uintptr        // expected sp at top of stack, to check in traceback
    param          unsafe.Pointer // passed parameter on wakeup
    atomicstatus   uint32
    stackLock      uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
    goid           int64 // goroutine id
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 goid int64 字段即为当前 goroutine 的 id。&lt;/p&gt;

&lt;h3 id=&#34;1-通过-stack-信息获取-goroutine-id&#34;&gt;1. 通过 stack 信息获取 goroutine id&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;bytes&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;runtime&amp;quot;
    &amp;quot;strconv&amp;quot;
)

func main() {
    fmt.Println(GetGID())
}

func GetGID() uint64 {
    b := make([]byte, 64)
    b = b[:runtime.Stack(b, false)]
    b = bytes.TrimPrefix(b, []byte(&amp;quot;goroutine &amp;quot;))
    b = b[:bytes.IndexByte(b, &#39; &#39;)]
    n, _ := strconv.ParseUint(string(b), 10, 64)
    return n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原理非常简单，将 stack 中的文本信息 &amp;ldquo;goroutine 1234&amp;rdquo; 匹配出来。但是这种方式有两个问题：&lt;/p&gt;

&lt;p&gt;stack 信息的格式随版本更新可能变化，甚至不再提供 goroutine id，可靠性差。
性能较差，调用 10000 次消耗 &amp;gt;50ms。&lt;/p&gt;

&lt;p&gt;如果你只是想在个人项目中使用 goid，这个方法是可以胜任的。维护和修改成本相对较低，且不需要引入任何第三方依赖。同时建议你就此打住，不要继续往下看了。&lt;/p&gt;

&lt;h3 id=&#34;2-通过修改源代码获取goroutine-id&#34;&gt;2. 通过修改源代码获取goroutine id&lt;/h3&gt;

&lt;p&gt;既然方法 1 效率较低，且不可靠，那么我们可以尝试直接修改源代码 &lt;code&gt;src/runtime/runtime2.go&lt;/code&gt; 中添加 Goid 函数，将 goid 暴露给应用层：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Goid() int64 {
    _g_ := getg()
    return _g_.goid
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方式能解决法 1 的两个问题，但是会导致你的程序只能在修改了源代码的机器上才能编译，没有移植性，并且每次 go 版本升级以后，都需要重新修改源代码，维护成本较高。&lt;/p&gt;

&lt;h3 id=&#34;3-通过-cgo-获取-goroutine-id&#34;&gt;3. 通过 CGo 获取 goroutine id&lt;/h3&gt;

&lt;p&gt;那么有没有性能好，同时不影响移植性，且维护成本低的方法呢？那就是来自 Dave Cheney 的 CGo 方式：&lt;/p&gt;

&lt;p&gt;文件 id.c：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;#include &amp;quot;runtime.h&amp;quot;

int64 ·Id(void) {
    return g-&amp;gt;goid;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件 id.go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package id

func Id() int64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整代码参见 &lt;a href=&#34;https://github.com/davecheney/junk/blob/master/id/id.c&#34;&gt;junk/id&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;这种方法的问题在于你需要开启 CGo, CGo 存在一些缺点，具体可以参见这个大牛的 &lt;a href=&#34;https://dave.cheney.net/2016/01/18/cgo-is-not-go&#34;&gt;cgo is not Go&lt;/a&gt;. 我相信在你绝大部分的工程项目中，你是不希望开启CGo的。&lt;/p&gt;

&lt;h3 id=&#34;4-通过汇编获取-goroutine-id&#34;&gt;4. 通过汇编获取 goroutine id&lt;/h3&gt;

&lt;p&gt;如果前面三种方法我们都不能接受，有没有第四种方法呢？那就是通过汇编获取goroutine id的方法。原理是：通过 getg 方法（汇编实现）获取到当前goroutine的g结构地址，根据偏移量计算出成员goid int的地址，然后取出该值即可。&lt;/p&gt;

&lt;p&gt;项目goroutine实现了这种方法。需要说明的是，这种方法看似简单，实际上因为每个go版本几乎都会有针对g结构的调整，因此goid int64的偏移并不是固定的，更加复杂的是，go在编译的时候，传递的编译参数也会影响goid int64的偏移值，因此，这个项目的作者花了非常多精力来维护每个go版本g结构偏移的计算，详见hack目录。&lt;/p&gt;

&lt;p&gt;这个方法性能好，原理清晰，实际使用上稳定性也不错（我们在部分不太重要的线上业务使用了这种方法）。但是，维护这个库也许真的太累了，最近发现作者将这个库标记为“DEPRECATED”，看来获取goroutine id是条越走越远的不归路😂&lt;/p&gt;

&lt;h3 id=&#34;5-通过汇编获取伪goroutine-id&#34;&gt;5. 通过汇编获取伪goroutine id&lt;/h3&gt;

&lt;p&gt;虽然方法4从原理和实际应用上表现都不错，但是毕竟作者弃坑了。回到我们要解决的问题上：我们并不是真的一定要获取到 goroutine id，我们只是想获取到 goroutine 的唯一标识。那么，从这个角度看的话，我们只需要解决 goroutine 标识唯一性的问题即可。&lt;/p&gt;

&lt;p&gt;显然，上面作者也想清楚了这个问题。他新开了一个库 &lt;a href=&#34;https://github.com/huandu/go-tls&#34;&gt;go-tls&lt;/a&gt;, 这个库实现了 goroutine local storage，其中获取 goroutine id 的方式是：用方法4的汇编获取 goroutine 的地址，然后自己管理和分配 goroutine id。由于它获取到的并不是真正的 goroutine id，因此我将之称为伪 goroutine id。其实现的核心代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
    tlsDataMap  = map[unsafe.Pointer]*tlsData{}
    tlsMu       sync.Mutex
    tlsUniqueID int64
)
...

func fetchDataMap(readonly bool) *tlsData {
    gp := g.G() // 1. 获取g结构地址
    if gp == nil {
        return nil
    }
    // Try to find saved data.
    needHack := false
    tlsMu.Lock()
    dm := tlsDataMap[gp]
    if dm == nil &amp;amp;&amp;amp; !readonly {
        needHack = true
        dm = &amp;amp;tlsData{
            id:   atomic.AddInt64(&amp;amp;tlsUniqueID, 1), // 2. 分配伪goroutine id
            data: dataMap{},
        }
        tlsDataMap[gp] = dm
    }
    tlsMu.Unlock()
    // Current goroutine is not hacked. Hack it.
    if needHack {
        if !hack(gp) {
            tlsMu.Lock()
            delete(tlsDataMap, gp)
            tlsMu.Unlock()
        }
    }
    return dm
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获取 g 结构地址。&lt;/li&gt;
&lt;li&gt;分配伪 goroutine id.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方式基本没有什么不能接受的 hack 实现，从原理上来说也更加安全。但是获取到不是你最开始想要的 goroutine id，不知你能否接受😅。&lt;/p&gt;

&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;

&lt;p&gt;获取 goroutine id 是一条不归路，目前也没有完美的获取它的方式。如果你一定要使用 goroutine id，先想清楚你要解决的问题是什么，如果没有必要，建议你不要走上这条不归路。尽早在团队中推广使用 context, 越早使用越早脱离对 goroutine id 的留恋和挣扎。&lt;/p&gt;

&lt;h3 id=&#34;credit&#34;&gt;Credit&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.sgmansfield.com/2015/12/goroutine-ids/&#34;&gt;Goroutine IDs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/issues/22770&#34;&gt;faq: document why there is no way to get a goroutine ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/85a08d8e7af3&#34;&gt;获取 Goroutine Id 的最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>PHONY target</title>
      <link>https://tosone.cn/post/phony-target/</link>
      <pubDate>Thu, 08 Mar 2018 21:14:28 +0000</pubDate>
      
      <guid>https://tosone.cn/post/phony-target/</guid>
      
        <description>&lt;p&gt;A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html&#34;&gt;https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you write a rule whose recipe will not create the target file, the recipe will be executed every time the target comes up for remaking. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;clean:
    rm *.o temp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the rm command does not create a file named clean, probably no such file will ever exist. Therefore, the rm command will be executed every time you say ‘make clean’.&lt;/p&gt;

&lt;p&gt;In this example, the clean target will not work properly if a file named clean is ever created in this directory. Since it has no prerequisites, clean would always be considered up to date and its recipe would not be executed. To avoid this problem you can explicitly declare the target to be phony by making it a prerequisite of the special target .PHONY (see Special Built-in Target Names) as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;.PHONY: clean
clean:
    rm *.o temp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once this is done, ‘make clean’ will run the recipe regardless of whether there is a file named clean.&lt;/p&gt;

&lt;p&gt;Phony targets are also useful in conjunction with recursive invocations of make (see Recursive Use of make). In this situation the makefile will often contain a variable which lists a number of sub-directories to be built. A simplistic way to handle this is to define one rule with a recipe that loops over the sub-directories, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;SUBDIRS = foo bar baz

subdirs:
    for dir in $(SUBDIRS); do \
        $(MAKE) -C $$dir; \
    done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are problems with this method, however. First, any error detected in a sub-make is ignored by this rule, so it will continue to build the rest of the directories even when one fails. This can be overcome by adding shell commands to note the error and exit, but then it will do so even if make is invoked with the -k option, which is unfortunate. Second, and perhaps more importantly, you cannot take advantage of make’s ability to build targets in parallel (see Parallel Execution), since there is only one rule.&lt;/p&gt;

&lt;p&gt;By declaring the sub-directories as .PHONY targets (you must do this as the sub-directory obviously always exists; otherwise it won’t be built) you can remove these problems:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;SUBDIRS = foo bar baz

.PHONY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)

$(SUBDIRS):
    $(MAKE) -C $@

foo: baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we’ve also declared that the foo sub-directory cannot be built until after the baz sub-directory is complete; this kind of relationship declaration is particularly important when attempting parallel builds.&lt;/p&gt;

&lt;p&gt;The implicit rule search (see Implicit Rules) is skipped for .PHONY targets. This is why declaring a target as .PHONY is good for performance, even if you are not worried about the actual file existing.&lt;/p&gt;

&lt;p&gt;A phony target should not be a prerequisite of a real target file; if it is, its recipe will be run every time make goes to update that file. As long as a phony target is never a prerequisite of a real target, the phony target recipe will be executed only when the phony target is a specified goal (see Arguments to Specify the Goals).&lt;/p&gt;

&lt;p&gt;Phony targets can have prerequisites. When one directory contains multiple programs, it is most convenient to describe all of the programs in one makefile ./Makefile. Since the target remade by default will be the first one in the makefile, it is common to make this a phony target named ‘all’ and give it, as prerequisites, all the individual programs. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;all: prog1 prog2 prog3
.PHONY: all

prog1: prog1.o utils.o
    cc -o prog1 prog1.o utils.o

prog2: prog2.o
    cc -o prog2 prog2.o

prog3: prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can say just ‘make’ to remake all three programs, or specify as arguments the ones to remake (as in ‘make prog1 prog3’). Phoniness is not inherited: the prerequisites of a phony target are not themselves phony, unless explicitly declared to be so.&lt;/p&gt;

&lt;p&gt;When one phony target is a prerequisite of another, it serves as a subroutine of the other. For example, here ‘make cleanall’ will delete the object files, the difference files, and the file program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;.PHONY: cleanall cleanobj cleandiff

cleanall: cleanobj cleandiff
    rm program

cleanobj:
    rm *.o

cleandiff:
    rm *.diff
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>RaspberryPi 上手</title>
      <link>https://tosone.cn/post/raspberry/</link>
      <pubDate>Sat, 25 Nov 2017 18:27:37 +0000</pubDate>
      
      <guid>https://tosone.cn/post/raspberry/</guid>
      
        <description>&lt;p&gt;当你花 35 美元买到一部树莓派（Raspberry Pi）计算机的时候，机器里面是没有预装操作系统（OS）的。这个时候你要自己下载一个 OS 到 SD 卡，插到树莓派上重启完成 OS 的安装。这一切看起来很简便，但你考虑过这个跟树莓派兼容的OS是哪里来的吗？&lt;/p&gt;

&lt;p&gt;其实，树莓派的操作系统 Raspbian 的来历可不简单。它诞生的前提是，每周 60 个小时的工作量，处理一大堆自建的 ARM 计算机以及重建 19000 组 Linux 软件包。而这一切，都是由两名志愿者完成的。他们是：麦克·汤姆森（Mike Thompson）和彼得·格林（Peter Green）。&lt;/p&gt;

&lt;h3 id=&#34;下载系统&#34;&gt;下载系统&lt;/h3&gt;

&lt;p&gt;适用于树莓派的系统有很多，这里主要说 Raspberry，从&lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;这里&lt;/a&gt;下载 &lt;a href=&#34;https://downloads.raspberrypi.org/raspbian_lite_latest&#34;&gt;Raspberry&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;烧写镜像到-sd-卡&#34;&gt;烧写镜像到 SD 卡&lt;/h3&gt;

&lt;p&gt;Windows 系统的话，需要这个软件 &lt;a href=&#34;https://sourceforge.net/projects/win32diskimager/&#34;&gt;win32diskimager&lt;/a&gt;。
在 Mac 上或者 Linux 上 用这个命令烧录进去 &lt;code&gt;sudo dd bs=4M if=raspbian.img of=/dev/sdb&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;在 raspbian 系统中的 boot 分区中新建一个空的文件并命名为 &lt;code&gt;ssh&lt;/code&gt;。当系统启动的时候将会启动 ssh，然后就可以用 ssh 连接上去。
目前下载的 raspbian 的系统都是基于 Debian 9 stretch 的，所以在 boot 分区下新建文件 &lt;code&gt;wpa_supplicant.conf&lt;/code&gt; 内容如下：&lt;/p&gt;

&lt;p&gt;{% codeblock wpa_supplicant.conf lang:apacheConf %}
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
network={
    ssid=&amp;ldquo;YOUR_NETWORK_NAME&amp;rdquo;
    psk=&amp;ldquo;YOUR_PASSWORD&amp;rdquo;
    key_mgmt=WPA-PSK
}
{% endcodeblock %}&lt;/p&gt;

&lt;p&gt;系统启动后将会把这个文件移动到 &lt;code&gt;/etc/wpa_supplicant/&lt;/code&gt; 文件夹下，然后自动连接 Wifi。&lt;/p&gt;

&lt;h3 id=&#34;查找内网-raspberrypi&#34;&gt;查找内网 RaspberryPi&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sudo nmap -sP 192.168.31.0/24 | awk &#39;/^Nmap/{ip=$NF}/B8:27:EB/{print ip}&#39;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;切换源&#34;&gt;切换源&lt;/h3&gt;

&lt;p&gt;只需要将 &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; 和 &lt;code&gt;/etc/apt/sources.list.d/raspi.list&lt;/code&gt; 中修改一下即可。&lt;/p&gt;

&lt;p&gt;{% codeblock /etc/apt/sources.list lang:bash %}
deb &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/&lt;/a&gt; stretch main contrib non-free rpi
deb-src &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/&lt;/a&gt; stretch main contrib non-free rpi
{% endcodeblock %}&lt;/p&gt;

&lt;p&gt;{% codeblock /etc/apt/sources.list.d/raspi.list lang:bash %}
deb &lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/raspberrypi/&#34;&gt;https://mirror.tuna.tsinghua.edu.cn/raspberrypi/&lt;/a&gt; stretch main ui
deb-src &lt;a href=&#34;https://mirror.tuna.tsinghua.edu.cn/raspberrypi/&#34;&gt;https://mirror.tuna.tsinghua.edu.cn/raspberrypi/&lt;/a&gt; stretch main ui
{% endcodeblock %}&lt;/p&gt;

&lt;h3 id=&#34;切换-dns&#34;&gt;切换 DNS&lt;/h3&gt;

&lt;p&gt;修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 为以下内容：&lt;/p&gt;

&lt;p&gt;{% codeblock /etc/resolv.conf lang:apacheConf %}
nameserver 9.9.9.9
{% endcodeblock %}&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Docker 入门</title>
      <link>https://tosone.cn/post/docker/</link>
      <pubDate>Sun, 07 May 2017 10:59:43 +0000</pubDate>
      
      <guid>https://tosone.cn/post/docker/</guid>
      
        <description>&lt;p&gt;Docker 安装以及常用数据库安装。&lt;/p&gt;

&lt;h3 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -sSL https://get.docker.com/ | sh
wget -qO- https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-docker-compose&#34;&gt;安装 Docker Compose&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -L https://github.com/docker/compose/releases/download/1.13.0/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/bin/docker-compose
chmod +x /usr/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-mongodb&#34;&gt;安装 MongoDB&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM mongo:latest
ENV MONGO_INITDB_ROOT_USERNAME mongodb_name
ENV MONGO_INITDB_ROOT_PASSWORD mongodb_passwd
COPY mongod.conf /etc/
EXPOSE 27017
CMD [&amp;quot;mongod&amp;quot;, &amp;quot;-f&amp;quot;, &amp;quot;/etc/mongod.conf&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;processManagement:
    fork: true
net:
    bindIp: &amp;quot;0.0.0.0&amp;quot;
    port: 27017
    maxIncomingConnections: 1000
    http:
        enabled: false
        JSONPEnabled: false
        RESTInterfaceEnabled: false
storage:
    dbPath: &amp;quot;/data/db&amp;quot;
    directoryPerDB: true
    journal:
        enabled: true
systemLog:
    destination: &amp;quot;file&amp;quot;
    path: &amp;quot;/var/log/mongodb/mongod.log&amp;quot;
    logAppend: true
security:
    authorization: &amp;quot;enabled&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t mongo-tosone .
docker run --name mongo -v /data/mongodb/data:/data/db --hostname=&amp;quot;mongodb&amp;quot; -p 27017:27017 -d mongo-tosone --smallfiles
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-mysql&#34;&gt;安装 Mysql&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM mysql:latest
ENV MYSQL_ROOT_PASSWORD 8541539655
ENV MYSQL_USER tosone
ENV MYSQL_PASSWORD 8541539655
CMD [&amp;quot;mysqld&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t mysql-tosone .
docker run --name mysql -v /data/mysql:/var/lib/mysql --hostname=&amp;quot;mysql&amp;quot; -p 3306:3306 -d mysql-tosone
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-redis&#34;&gt;安装 Redis&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM redis:latest
COPY redis.conf /etc/redis/redis.conf
CMD [ &amp;quot;redis-server&amp;quot;, &amp;quot;/etc/redis/redis.conf&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;################################## INCLUDES ###################################
################################## NETWORK #####################################
bind 0.0.0.0
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
################################# GENERAL #####################################
daemonize no
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &amp;quot;&amp;quot;
databases 16
################################ SNAPSHOTTING  ###############################
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir ./
################################# REPLICATION #################################
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
################################## SECURITY ###################################
requirepass 8541539655
################################### LIMITS ####################################
############################## APPEND ONLY MODE ###############################
appendonly no
appendfilename &amp;quot;appendonly.aof&amp;quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
################################ LUA SCRIPTING  ###############################
lua-time-limit 5000
################################ REDIS CLUSTER  ##############################
################################## SLOW LOG ###################################
slowlog-log-slower-than 10000
slowlog-max-len 128
################################ LATENCY MONITOR ##############################
latency-monitor-threshold 0
############################# EVENT NOTIFICATION ##############################
notify-keyspace-events &amp;quot;&amp;quot;
############################### ADVANCED CONFIG ###############################
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker build -t redis-tosone .
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>如何才能看到不该看到的东西</title>
      <link>https://tosone.cn/post/shadowsocks-ppt/</link>
      <pubDate>Fri, 05 May 2017 12:48:41 +0000</pubDate>
      
      <guid>https://tosone.cn/post/shadowsocks-ppt/</guid>
      
        <description>&lt;p&gt;有人不想让我们看见一些东西。&lt;/p&gt;

&lt;h4 id=&#34;墙从-何-处来&#34;&gt;墙从 &amp;ldquo;何&amp;rdquo; 处来&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;方滨兴（1960 年 7 月 17 日－），中国共产党党员，中国工程院院士，全国人大代表。曾任北京邮电大学校长，国家计算机网络与信息安全管理中心主任兼总工程师、信息产业部互联网应急处理协调办公室主任。现任国家信息化专家咨询委员会网络与信息安全专委会副主任，国家互联网信息办公室专家委员会委员；第十一届全国人大代表，北京市第十四届人大常务委员会委员；国家 863 计划 &amp;ldquo;十二五&amp;rdquo; 专家委员会委员，中国通信学会副理事长。他是中国信息安全专家之一，也是中国网络审查体系防火长城（GFW）关键部分的首要设计师，因此被网友称为 &amp;ldquo;中国防火墙之父&amp;rdquo; ，其官方在线简历也显示他主持建设了 &amp;ldquo;国家网络安全监控平台&amp;rdquo; 等多个相关系统。 &amp;ndash; 引用自&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%96%B9%E6%BB%A8%E5%85%B4&#34;&gt;维基百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2011 年 5 月 19 日上午，网友在推特称 &amp;ldquo;下午方滨兴将出现在武汉大学计算机学院 B 座 4 楼&amp;rdquo;，很快在网络上开始了一场 &amp;ldquo;悬赏&amp;rdquo; 袭击方滨兴的活动。当天下午，方滨兴在武汉大学教学大楼下车时，遭一学生从背后扔鞋袭击。据报道，现场有学生准备了鸡蛋，该学生先向方滨兴投掷了鸡蛋，但未投中。随后，该学生脱下脚上鞋子向其扔去，第一只鞋打中了方滨兴，但第二只鞋被一男一女挡住。事后华中科技大学和武汉大学对此事低调处理，肇事学生也未见被抓捕归案。然而此事早已在网络上传播甚广。中共官方媒体新华社下属新华网也转载了《云南信息报》的报道。在接受 CNN 的专访时，该发布消息的网友说：&amp;rdquo;我不高兴他（方滨兴）做的事情。他让我花不必要的钱去访问本该是能够免费访问的网站，他使我的网上冲浪很不方便。&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gfw-不是墙&#34;&gt;GFW 不是墙&lt;/h3&gt;

&lt;p&gt;GFW 其实是一个入侵检测系统 (IDS)。你的每一次跨境访问都是被当做一次入侵，根据对你的流量分析是否拒绝访问，返回 RST 或者返回一个奇怪的 IP。&lt;/p&gt;

&lt;h4 id=&#34;gfw-的封锁方式&#34;&gt;GFW 的封锁方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;DNS 污染&lt;/li&gt;
&lt;li&gt;DNS 劫持&lt;/li&gt;
&lt;li&gt;IP 路由劫持&lt;/li&gt;
&lt;li&gt;深度包检测&lt;/li&gt;
&lt;li&gt;热点分析&lt;/li&gt;
&lt;li&gt;伪造证书&lt;/li&gt;
&lt;li&gt;机房白名单制&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;协议符合什么特征才可以翻墙&#34;&gt;协议符合什么特征才可以翻墙&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;数据被加密，任何可以截取到数据流的人，无法解密出原始数据&lt;/li&gt;
&lt;li&gt;观察一段数据流量，是否能判别这是一个代理协议的流量&lt;/li&gt;
&lt;li&gt;对于一个仅暴露出 TCP 端口的黑箱，能否判断这个端口提供了代理服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;gfw-干过多少匪夷所思的事&#34;&gt;GFW 干过多少匪夷所思的事&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GitHub 怎么访问不了了&lt;/li&gt;
&lt;li&gt;我的网站怎么没办法访问了&lt;/li&gt;
&lt;li&gt;怎么大面积的网站被转发到了同一个 IP&lt;/li&gt;
&lt;li&gt;北京的根域名服务器被移除了国际认可&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;有墙的历史之后就有了翻墙的历史&#34;&gt;有墙的历史之后就有了翻墙的历史&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;不会翻墙的程序员是没有走在正确的康庄大道上，不会翻墙的民众就不是明事理的民众，翻墙是你的必备技能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻墙的话，方法有很多，直接到百度上搜一下关键词 vpn 也是可以搜到很多相关信息。很多乱七八糟的那些网站里边的东西也都是可以用的。但是有一点，那些网站里边的东西可能并不会长久，可能隔一段时间网站就消失了，找不到了，你花钱买的翻墙利器也就没了保障。&lt;/p&gt;

&lt;p&gt;说一点黑历史，之前 UC 浏览器中有一个翻墙的神器叫红杏出墙，当时觉得特别好用，也是免费的。翻墙嘛，毕竟也是国家花大力气建造的 GFW 来做这堵墙的，这么好的工具很定不能让你轻易地用啊。之后 UC 就撤掉了这个插件，现在也找不到了，现在关于红杏出墙的所有网站都算是空壳了，千万不要再相信关于红杏出墙的任何网站，想当年红杏出墙的克隆网站、钓鱼网站相当之多，现在已经是凄凄惨惨戚戚。后来也是出现一些翻墙浏览器，简单的就是说，在浏览器中做了一些插件，只需要把人家提供的浏览器装上去，就可以翻墙了，但是无奈，这种东西能用的时间太过于短了，市场需要更新，对于嫌麻烦的人来说这简直就是不可以忍受的。&lt;/p&gt;

&lt;h4 id=&#34;ssh-翻墙&#34;&gt;SSH 翻墙&lt;/h4&gt;

&lt;p&gt;SSH -D 利用 SSH 的动态绑定的功能。&lt;/p&gt;

&lt;p&gt;SSH 这种协议是加密的没有问题，有非对称加密也没有问题，关键是后边是对称加密，因为 SSH 认为一直采用非对称加密来传输消息太慢了。这就造成了一个问题，用对称的加密算法加密 HTTP 协议的流量的时候数据包是有特征的。&lt;/p&gt;

&lt;p&gt;当 GFW 分析到你的流量特征中含有 HTTP 的数据的时候将会时不时的逗你一下，让你断一下线什么的。&lt;/p&gt;

&lt;h4 id=&#34;tor&#34;&gt;Tor&lt;/h4&gt;

&lt;p&gt;The Onion Router，洋葱路由&lt;/p&gt;

&lt;p&gt;Tor 主要是用来做一些比较私密性的交流或者网络活动在能用到的。Tor 的特点就是需要多个网桥从中间中继你的网络流量，每个网桥只是简单的相互投递匿名信，经过多轮的投递之后，每个中继只是知道这封信是上个中继的，但是并不知道这封信的具体作者是谁。&lt;/p&gt;

&lt;p&gt;Tor 的更大的作用是让交流更私密，并不适用于翻墙。&lt;/p&gt;

&lt;p&gt;GFW 虽然说不能知道你和中继之间交流的数据，但是他会经常打入到 Tor 网络的内部去封锁一些中继节点。&lt;/p&gt;

&lt;h4 id=&#34;vpn-翻墙&#34;&gt;VPN 翻墙&lt;/h4&gt;

&lt;p&gt;国家已经出台了相关的政策，VPN 翻墙以后要备案，未经允许的翻墙属于违法行为。已经不太适用于个人用户了，属于企业及政府之类的。&lt;/p&gt;

&lt;h4 id=&#34;lantern&#34;&gt;Lantern&lt;/h4&gt;

&lt;p&gt;还有一个不得不说的工具 Lantern ，这个工具是基于 P2P 的，这种点对点的协议屏蔽的很多的中间环节，所以说能够翻墙，但是在国内想封锁 Lantern 是比较容易的，只是说国家在很大程度上不想让绝大多数人翻墙而已，这才是GFW的目的，目前 Lantern 是时不时就不能用的玩意儿。&lt;/p&gt;

&lt;p&gt;Lantern 是基于 P2P 的每个安装了 Lantern 的人都是一个中继节点，当然墙外的人就很少人去装这个 Lantern 了。所以需要有人在墙外去公开一些节点，每个稳定的节点都是要用钱的。不过不太好的是这种 P2P 的协议及其容易被 Gank 掉。只要 GFW 知道 Lantern 会链接哪些 IP 封锁掉就行了。&lt;/p&gt;

&lt;h4 id=&#34;squid&#34;&gt;Squid&lt;/h4&gt;

&lt;p&gt;Squid 以 https 的方式提供代理服务，然后在客户端机器使用 chrome 访问被封的网站。&lt;/p&gt;

&lt;h4 id=&#34;shadowsocks&#34;&gt;Shadowsocks&lt;/h4&gt;

&lt;p&gt;Long long ago, 在一个叫 v2ex 的地方，有一位叫做 clowwindy 的用户，其实是中国人。他为了避免网络流量分类技术和 ssh tunnel 的低效，自己写了一个用于加密流量的协议，并自用了一年多. 后来，由于这个协议非常高效，而且使用json 作为配置文件，配置起来非常方便，所以迅速赢得了很多用户，并在 v2ex 上有了一个专属的节点。shadowsocks 迅速被移植到各种平台、各种语言，用户也急剧上升，并且有了专门经营 shadowsocks 服务的商家。&lt;/p&gt;

&lt;p&gt;Shadowsocks 可以跨过 GFW 的原因在于它的流量特征无法被检测到。例如：AES-CFB，由于加密流程和解密流程中被块加密器加密的数据是前一段密文，因此即使明文数据的长度不是加密块大小的整数倍也是不需要填充的，这保证了数据长度在加密前后是相同的。&lt;/p&gt;

&lt;p&gt;Shadowsocks 发展了这么多年，SS 足够稳定、快速、高效，涵盖各大主流平台、100% 翻墙无障碍，这就足够了。&lt;/p&gt;

&lt;h5 id=&#34;从协议上加速-shadowsocks&#34;&gt;从协议上加速 shadowsocks&lt;/h5&gt;

&lt;p&gt;Shadowsocks 如何才能更快呢？基于 TCP 协议的，3 次握手 4 次断开确实很费劲，有些人说为什么不可以用 UDP 呢？但是 UDP 虽然说是很快，但是如果想下载一个很完整的文件的时候，很容易出现丢包的现象，造成下载失败。那么 UDP TCP 的特性合并一下，基于 UDP 做一个安全的 TCP 的传输，有一个 SRUDP。&lt;/p&gt;

&lt;p&gt;有人做了一个 KCP，结合了 TCP 的一些缺陷设计的。&lt;/p&gt;

&lt;p&gt;从 Linux kernel &lt;a href=&#34;https://github.com/shadowsocks/shadowsocks/wiki/%E4%BC%98%E5%8C%96-Shadowsocks&#34;&gt;优化 Shadowsocks&lt;/a&gt; 让服务更快。&lt;/p&gt;

&lt;h4 id=&#34;最完美的解决方案&#34;&gt;最完美的解决方案&lt;/h4&gt;

&lt;p&gt;肉身翻墙&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Feature Branch Workflow 实践</title>
      <link>https://tosone.cn/post/feature-branch/</link>
      <pubDate>Sat, 22 Apr 2017 14:23:31 +0000</pubDate>
      
      <guid>https://tosone.cn/post/feature-branch/</guid>
      
        <description>&lt;p&gt;这只是一份关于 Feature Branch Workflow 实践的建议。&lt;/p&gt;

&lt;h3 id=&#34;feature-branch-命名规则&#34;&gt;Feature Branch 命名规则&lt;/h3&gt;

&lt;p&gt;采用 &lt;code&gt;^(feature|bugfix|hotfix)/\d+-[\w-]+$&lt;/code&gt; 来命名分支，其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;feature&lt;/code&gt; 新功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bugfix&lt;/code&gt; 针对 &lt;code&gt;master&lt;/code&gt; 主分支的 bug 修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hotfix&lt;/code&gt; 针对特定标签版本的 bug 修正&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d+&lt;/code&gt; Coding.net 上的项目讨论 id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[\w-]+&lt;/code&gt; 具体的分支名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;feature/123-new-user&lt;/code&gt; 一个新功能，讨论 id 是 &lt;code&gt;123&lt;/code&gt;，功能是新用户；feature 理论上是相互独立的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bugfix/456-user-name&lt;/code&gt; 一个 bug 修正，讨论 id 是 &lt;code&gt;456&lt;/code&gt;，修正用户名称相关的问题；bug 也会影响到其他 feature 分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hotfix/789-server-config&lt;/code&gt; 一个热修复，讨论 id 是 &lt;code&gt;789&lt;/code&gt;，修正服务器配置问题；需要优先处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当团队出现超过十个并发分支进行开发时，规范的命名分支名称方便团队有效使用分支。
分支名以 &lt;code&gt;hotfix&lt;/code&gt; 和 &lt;code&gt;bugfix&lt;/code&gt; 开头更能提示团队成员优先处理（评审）相关分支，并且建议团队成员将其合并到各自当前工作的 feature 分支进行测试反馈。
分支名中的讨论 id 便于团队成员了解变更内容，具体的分支名需要简明扼要的描述变更。&lt;/p&gt;

&lt;h3 id=&#34;使用-tag-标签发布正式版本&#34;&gt;使用 tag 标签发布正式版本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;master&lt;/code&gt; 主分支默认使用 CI 部署到 staging 预发布服务器，以供内部人员（产品/测试）审阅。
正式的 production 生产服务器只部署 git tag 发布的版本。&lt;/p&gt;

&lt;p&gt;正常的发布流程是在 &lt;code&gt;master&lt;/code&gt; 上验收之后，使用 &lt;code&gt;git tag&lt;/code&gt; 命令或在 Coding.net 网站增加标签。
标签使用 &lt;code&gt;^\d{4}\.\d{1,2}\.\d{1,2}(\.\d+)?$&lt;/code&gt; 命名，其中前三个数字是当前发布时间的年、月、日，最后一个数字当天发布的累计次数，默认不需要。
如 &lt;code&gt;2017.4.11&lt;/code&gt;、&lt;code&gt;2017.4.11.1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一般来说，中小型网站应用只需要维护一个生产版本。但实际的需要，如因为产品验收导致的预发布与生产环境分离，或者无法让使用者有效确认当前发布的版本等等。
就需要正式发布采用 git 增加标签来发布，并指明版本。&lt;/p&gt;

&lt;p&gt;同时，若非必要，指明版本还可以支持生产环境发布的撤回与切换。&lt;/p&gt;

&lt;h3 id=&#34;hotfix-热修复&#34;&gt;Hotfix 热修复&lt;/h3&gt;

&lt;p&gt;Hotfix 热修复与普通的 bugfix 不一样，bugfix 是针对 &lt;code&gt;master&lt;/code&gt; 主分支，而 hotfix 是针对 git 标签。Hotfix 分支是从指定 tag 上检出。
虽然也需要提交合并请求到 &lt;code&gt;master&lt;/code&gt; 主分支，但其在合并操作之前，评审通过之后，在其分支上直接增加 git 标签。&lt;/p&gt;

&lt;p&gt;这样做的目的是避免 &lt;code&gt;master&lt;/code&gt; 主分支上未正式发布的代码污染生产环境。&lt;/p&gt;

&lt;h3 id=&#34;避免大的合并请求&#34;&gt;避免大的合并请求&lt;/h3&gt;

&lt;p&gt;项目的所有代码都需要经过合并请求中评审 review 过程。
最保守的方案也需要团队中有人对所有代码负责以便需要时能有人来解决问题。&lt;/p&gt;

&lt;p&gt;激进的方案是团队中所有人都参与到评审中，各负其责，每个人评审的目的是不同的。
有的人可以通盘掌控，有的人需要仔细审查项目中的部分代码，有的人只需要检查代码注释与文档。&lt;/p&gt;

&lt;p&gt;所以，要避免大的合并请求，代码、注释、讨论、合并请求说明乃至 git 提交日志都需要方便审核。&lt;/p&gt;

&lt;p&gt;一般来说，Bugfix 分支的目的是解决问题，Hotfix 分支更为激进，甚至可以直接了当的通过删除代码来解决问题。
Feature 分支会相对复杂，但也不能过分复杂。&lt;/p&gt;

&lt;p&gt;对于复杂或庞大的新需求，需要合理的拆解成多个小需求，转换成多个 feature 分支，多个合并请求。
因为 &lt;code&gt;master&lt;/code&gt; 主分支已经与生产环境脱钩，所以每个小的 feature 分支都需要尽快建立合并请求，
尽快进行团队评审，尽快合并到 &lt;code&gt;master&lt;/code&gt;，尽快发布给内部人员审阅。&lt;/p&gt;

&lt;h3 id=&#34;团队协作&#34;&gt;团队协作&lt;/h3&gt;

&lt;p&gt;团队协作加快开发速度的关键在于合理的拆分需求到不同的 feature 分支，理想境地是不同分支互不干扰，齐头并进。但这几乎是不可能的。&lt;/p&gt;

&lt;p&gt;基于避免大的合并请求理念，团队中每个人实际上分配到的都是多个小需求。
这其中包括一个完整功能开发的不同阶段分成多个 feature 分支，这些分支存在先后顺序，分别由团队中不同角色的成员去开启，去完成。&lt;/p&gt;

&lt;p&gt;这些更加考校团队成员对需求的理解与相互之间沟通的能力。还好，我们有很好的评审渠道去加强沟通。&lt;/p&gt;

&lt;p&gt;所以，增加团队成员是可以提高生产力，但不是绝对。但可以确定的是，一群好的团队成员不仅能提高生产力，更能带来更好的质量。&lt;/p&gt;

&lt;p&gt;团队协作更注重于团队中成员的互补性，相互之间的配合。&lt;/p&gt;

&lt;h3 id=&#34;实现大规模需求与重构&#34;&gt;实现大规模需求与重构&lt;/h3&gt;

&lt;p&gt;项目中很多时候都不得不迎来很大的新功能实现、变更甚至整个项目的重构。
这时候，我们需要一个新的主开发分支甚至一个新仓库。&lt;/p&gt;

&lt;p&gt;有资源的团队最好是从主仓库派生一个新仓库来实现大的变更。&lt;/p&gt;

&lt;p&gt;当然，也可以采用从 &lt;code&gt;master&lt;/code&gt; 分支检出一个新的开发主分支。
这个分支既不是 feature 分支也不是 bugfix 或 hotfix 分支，
而是与 &lt;code&gt;master&lt;/code&gt; 同等地位，直到它能通过合并请求合并进 &lt;code&gt;master&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以，该分支可以直接命名，比如 &lt;code&gt;new-structure&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在合并进 &lt;code&gt;master&lt;/code&gt; 分支之前，此分支和 &lt;code&gt;master&lt;/code&gt; 一样也可以接受来自 feature 分支和 bugfix 分支的合并请求。
仍然使用我们已有的工作流，只不过换了对象。&lt;/p&gt;

&lt;p&gt;需要注意的是，同时维持多个 feature 分支向两个不同的主分支提交合并请求是很危险的事情。
它会加大新的开发主分支回到 &lt;code&gt;master&lt;/code&gt; 的风险。&lt;/p&gt;

&lt;p&gt;在回到 &lt;code&gt;master&lt;/code&gt; 之前，只对 &lt;code&gt;master&lt;/code&gt; 分支做有限维护，比如 hotfix 是最好的。&lt;/p&gt;

&lt;h3 id=&#34;一个人的评审&#34;&gt;一个人的评审&lt;/h3&gt;

&lt;p&gt;大多数项目实际都只有一个开发成员，但此时，评审仍然不可或缺。&lt;/p&gt;

&lt;p&gt;所以，即使是一个人的项目，也要采用本工作流，老老实实的在合并请求中自己做评审。&lt;/p&gt;

&lt;p&gt;你可以交替多个 feature 分支，分别开发，然后评审上一个提交的 feature 分支。&lt;/p&gt;

&lt;p&gt;良好的评审习惯，会很快提高自己的代码质量。&lt;/p&gt;

&lt;p&gt;而且，不管是对于个人还是项目来说，都是和团队开发一样的开发模式。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Generate SSH key and GPG key</title>
      <link>https://tosone.cn/post/ssh-gpg-keys/</link>
      <pubDate>Sat, 22 Apr 2017 13:16:42 +0000</pubDate>
      
      <guid>https://tosone.cn/post/ssh-gpg-keys/</guid>
      
        <description>&lt;p&gt;2012年3月4号，GitHub 的&lt;a href=&#34;https://github.com/blog/1068-public-key-security-vulnerability-and-mitigationhttp://&#34;&gt;公钥安全漏洞&lt;/a&gt;被一个叫 Egor Homakov 的俄国人利用了。这个漏洞允许他向 GitHub 上的 Ruby on Rails 框架的主分支上提交代码。&lt;a href=&#34;http://www.oschina.net/translate/git-horror-story&#34;&gt;Git 使用中的教训：签名提交确保代码完整可信&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;ssh-key-的生成及使用&#34;&gt;SSH key 的生成及使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;生成一个 SSH key &lt;code&gt;ssh-keygen -t rsa -b 4096 -C &amp;quot;i@tosone.cn&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将生成的 SSH key 复制至剪切板 &lt;code&gt;pbcopy &amp;lt; ~/.ssh/id_rsa.pub&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 GitHub 中这个&lt;a href=&#34;https://github.com/settings/keys&#34;&gt;页面&lt;/a&gt;添加 SSH key。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gpg-key-的生成及使用&#34;&gt;GPG key 的生成及使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;生成一个 GPG key &lt;code&gt;gpg --gen-key&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;配置将要使用的 GPG key &lt;code&gt;git config --global user.signingkey 0A46826A&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;配置 GIT &lt;code&gt;git config --global commit.gpgsign true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 GitHub 中这个&lt;a href=&#34;https://github.com/settings/keys&#34;&gt;页面&lt;/a&gt;添加 GPG key。&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>ECS init</title>
      <link>https://tosone.cn/post/ecs-init/</link>
      <pubDate>Mon, 17 Apr 2017 21:38:24 +0000</pubDate>
      
      <guid>https://tosone.cn/post/ecs-init/</guid>
      
        <description>&lt;p&gt;ECS 新购主机 Ubuntu 初始化的一些操作。&lt;/p&gt;

&lt;h3 id=&#34;重置主机名&#34;&gt;重置主机名&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;修改你的自己的个性化主机名 &lt;code&gt;vi /etc/hostname&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;完事之后还需要修改 &lt;code&gt;vi /etc/hosts&lt;/code&gt; &lt;a href=&#34;https://askubuntu.com/questions/59458/error-message-when-i-run-sudo-unable-to-resolve-host-none&#34;&gt;原因请看&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;最后 &lt;code&gt;apt update&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;挂载数据盘&#34;&gt;挂载数据盘&lt;/h3&gt;

&lt;p&gt;系统盘是系统该有东西，总是要有个存储数据的地方，所以你需要有一个数据盘。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看未挂载的磁盘 &lt;code&gt;fdisk -l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建分区 &lt;code&gt;fdisk /dev/xvdb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;格式化分区 &lt;code&gt;mkfs.ext3 /dev/xvdb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;挂载目录 &lt;code&gt;mkdir /data &amp;amp;&amp;amp; mount /dev/xvdb /data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自动挂载 &lt;code&gt;vi /etc/fstab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加 &lt;code&gt;/dev/xvdb /data ext3 defaults 0 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启 &lt;code&gt;reboot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看分区信息 &lt;code&gt;df&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建用户&#34;&gt;创建用户&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;adduser tosone
apt install sudo
gpasswd -a tosone sudo
visudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;# User privilege specification&lt;/code&gt; 这里行下边添加一行 &lt;code&gt;tosone ALL=(ALL:ALL) ALL&lt;/code&gt;。tosone 这个用户将使用密码来拥有所有 root 拥有的权限。&lt;/p&gt;

&lt;h3 id=&#34;复制公钥&#34;&gt;复制公钥&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ssh-key-copy tosone@ip&lt;/code&gt; 将自己的 pubkey 复制到远程的主机上，然后后续不再需要密码登录主机了。&lt;/p&gt;

&lt;h3 id=&#34;安装常用软件&#34;&gt;安装常用软件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt-get install redis-server mosquitto python-pip vim zsh git supervisor curl
sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash
echo &amp;quot;export NVM_DIR=\&amp;quot;\$HOME/.nvm\&amp;quot;&amp;quot; &amp;gt;&amp;gt; ~/.zshrc
echo &amp;quot;[ -s \&amp;quot;\$NVM_DIR/nvm.sh\&amp;quot; ] &amp;amp;&amp;amp; . \&amp;quot;\$NVM_DIR/nvm.sh\&amp;quot;&amp;quot; &amp;gt;&amp;gt; ~/.zshrc
source ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Compile Opencv</title>
      <link>https://tosone.cn/post/compile-opencv/</link>
      <pubDate>Sat, 15 Apr 2017 14:22:24 +0000</pubDate>
      
      <guid>https://tosone.cn/post/compile-opencv/</guid>
      
        <description>&lt;p&gt;OpenCV is released under a BSD license and hence it’s free for both academic and commercial use. It has C++, C, Python and Java interfaces and supports Windows, Linux, Mac OS, iOS and Android. OpenCV was designed for computational efficiency and with a strong focus on real-time applications. Written in optimized C/C++, the library can take advantage of multi-core processing. Enabled with OpenCL, it can take advantage of the hardware acceleration of the underlying heterogeneous compute platform.&lt;/p&gt;

&lt;h3 id=&#34;step-1&#34;&gt;STEP 1&lt;/h3&gt;

&lt;p&gt;To install the dependencies required for OpenCV, just run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get -y install libopencv-dev build-essential cmake git libgtk2.0-dev libgtk-3-dev \
                        pkg-config python-dev python-numpy libdc1394-22 libdc1394-22-dev \
                        libjpeg-dev libpng-dev libpnglite-dev libpng++-dev libtiff5-dev \
                        libavcodec-dev libavformat-dev libswscale-dev libxine2-dev \
                        libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libv4l-dev \
                        libtbb-dev libqt4-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev \
                        libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 \
                        v4l-utils unzip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-2&#34;&gt;STEP 2&lt;/h3&gt;

&lt;p&gt;Download the latest version of &lt;a href=&#34;https://github.com/opencv/opencv&#34;&gt;OpenCV&lt;/a&gt;. Or from &lt;a href=&#34;https://share.weiyun.com/c01ee33744d180629d3ae779b75b8d43&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://github.com/opencv/opencv/archive/${version}.zip
unzip ${version}.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-3&#34;&gt;STEP 3&lt;/h3&gt;

&lt;p&gt;Sometimes compile opencv will get an error that cannot downlaod ippicv.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir 3rdparty/ippicv/downloads/linux-808b791a6eac9ed78d32a7666804320e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then copy the ippicv file in that directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build
cd build
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-4&#34;&gt;STEP 4&lt;/h3&gt;

&lt;p&gt;Finishing compile.&lt;/p&gt;

&lt;p&gt;Now some final touches:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo /bin/bash -c &#39;echo &amp;quot;/usr/local/lib&amp;quot; &amp;gt; /etc/ld.so.conf.d/opencv.conf&#39;
sudo ldconfig
sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the complete process execute reboot your system.&lt;/p&gt;

&lt;p&gt;Now you have a working installation of OpenCV.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang auto build version</title>
      <link>https://tosone.cn/post/golang-auto-build-versioning/</link>
      <pubDate>Tue, 11 Apr 2017 20:26:54 +0000</pubDate>
      
      <guid>https://tosone.cn/post/golang-auto-build-versioning/</guid>
      
        <description>&lt;p&gt;We needed a version number to find whether the binary was from yesterday or today’s source. Then we decided that for all our golang applications we should have a way to find out the version number, so that we can always query and find out which version it is, there by which source is running.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

var (
    BuildStamp = &amp;quot;Nothing Provided.&amp;quot;
    GitHash   = &amp;quot;Nothing Provided.&amp;quot;
)

func main() {
    fmt.Printf(&amp;quot;Git Commit Hash: %s\n&amp;quot;, GitHash)
    fmt.Printf(&amp;quot;UTC Build Time: %s\n&amp;quot;, BuildStamp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在只需要，这样 build 这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -ldflags &amp;quot;-X main.GitHash=`git rev-parse HEAD` \
                   -X main.BuildStamp=`date -u &#39;+%Y-%m-%d_%I:%M:%S%p&#39;`&amp;quot; main.go
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>泰山旅游指南</title>
      <link>https://tosone.cn/post/mount-tai-reference/</link>
      <pubDate>Sat, 04 Mar 2017 16:57:15 +0000</pubDate>
      
      <guid>https://tosone.cn/post/mount-tai-reference/</guid>
      
        <description>&lt;p&gt;泰山，以五岳独尊名扬天下，中国历代曾有 72 位皇帝到泰山封禅。杜甫一首《望岳》中的“会当凌绝顶，一览众山小”表达出自信自励的意志和坚定豪迈的气概，亦充分体现出泰山的巍峨雄伟与险峻。&lt;/p&gt;

&lt;h3 id=&#34;如何前往泰山&#34;&gt;如何前往泰山&lt;/h3&gt;

&lt;h5 id=&#34;泰山的位置&#34;&gt;泰山的位置&lt;/h5&gt;

&lt;p&gt;泰山坐落于泰安市北，是泰安地区标志性景点。想要登泰山，首先要抵达泰安市。由于泰安距离济南不远，而且目前泰安没有民用机场，所以其他城市抵达泰安首选的交通工具是火车。&lt;/p&gt;

&lt;h5 id=&#34;泰山站和泰安站的区别&#34;&gt;泰山站和泰安站的区别&lt;/h5&gt;

&lt;p&gt;泰安市一共有两个火车站，购买火车票的时候需要注意的地方就是【泰山站】和【泰安站】并非是同一个车站。具体如何区分这两个车站，可以参考当地人的叫法：泰安站出发的都是动车，当地人都把【泰安站称为高铁站】；泰山站出发的都是普通列车，距离泰安市区最近，所以当地人都把这个车站直接成为【火车站】。&lt;/p&gt;

&lt;h5 id=&#34;如何前往登山口&#34;&gt;如何前往登山口&lt;/h5&gt;

&lt;p&gt;如果打算从红门上山，可直接在泰山站乘坐 3 路公交车（ 2 元）或乘坐出租车到红门或天外村（车费在 10 元左右）；若是由泰安站下车，可乘 37 路公交车至红门或天外村，也可选择乘坐出租车从泰安站至红门或天外村约40分钟左右，车费大约在 35 元左右。如果选择桃花峪游览路线登山，可以从泰山站乘坐 16 路公交车到达。如果选择天烛峰游览路线登山，可以从泰山站乘坐 19 路公交车到达。&lt;/p&gt;

&lt;h3 id=&#34;登泰山的4条线路如何选择&#34;&gt;登泰山的4条线路如何选择&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;泰山中路-最经典的登山线路&lt;/li&gt;
&lt;li&gt;泰山西路-最省力的登山线路&lt;/li&gt;
&lt;li&gt;天烛峰-最古朴自然的登山线路&lt;/li&gt;
&lt;li&gt;桃花峪-最浪漫的登山线路&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;{% image fancybox fig-50 clear /assets/images/route-tai.jpeg &amp;ldquo;泰山路线图&amp;rdquo; %}&lt;/p&gt;

&lt;h3 id=&#34;泰山中路-最经典的登山线路&#34;&gt;泰山中路 - 最经典的登山线路&lt;/h3&gt;

&lt;p&gt;此登山线路以【岱庙】为起点 ，是泰山上人文和自然景观最集中的经典登山线路，也是泰山的精华所在，全程 9.5 公里，盘道 7000 多节，山脚至山顶之间几乎没有平路。历朝皇帝封禅皆为此处登山，本线路也被称为泰山御道。途中树木郁郁葱葱，阶梯盘旋而上，山峰奇秀俊美，人文古迹众多，古朴寺庙8处、碑碣200多块、摩崖刻石 300 多处，可以充分体验传统文化的韵味。&lt;/p&gt;

&lt;p&gt;该路线途径：岱庙（门票 30 元每位）—— 岱宗坊 —— 红门宫 —— 万仙楼（进山购票处：125元每位）—— 斗母宫 —— 经石峪 —— 壶天阁 —— 回马岭 —— 中天门 —— 快活三里 —— 云步桥 —— 五大夫松 —— 十八盘 —— 南天门 —— 天街 —— 碧霞祠 —— 唐摩崖 —— 五岳独尊 —— 玉皇顶 —— 拱北石&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初次登泰山者，强烈推荐由此处登山。登泰山没走过这条线路，不算真正意义游览过泰山。&lt;/li&gt;
&lt;li&gt;从红门步行登至山顶，成年人需大约 4 — 6 小时。也可以从岱庙开始游览，需多出 1 — 2 小时游览时间。&lt;/li&gt;
&lt;li&gt;本线路如果全程步行登山，对体力和毅力是一向考验。如登山途中体力不支，可在【中天门】换乘索道抵达山顶。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;泰山西路-最省力的登山线路&#34;&gt;泰山西路 - 最省力的登山线路&lt;/h3&gt;

&lt;p&gt;此线路以【天外村广场】为起点，是最为方便、省时、省力的登山线路。登山线路分为两段：前段为天外村至半山腰的中天门的盘山公路，路程为 14.35 公里，景区交通车时间为 30 分钟左右，沿途有很多自然景观和历史遗迹，可随车欣赏沿途美景；后段为中天门至山顶，可以选择步行登山（约 2 小时）或者乘坐索道（约 15 分钟）。&lt;/p&gt;

&lt;p&gt;该路线途径：天外村（进山购票处：125 元/位；景区交通车：30 元/位）—— 龙潭水库 —— 白龙池 —— 黑龙潭 —— 竹林寺 —— 黄溪河水库 —— 扇子崖 —— 傲徕峰 —— 中天门 —— 索道（100 元/位）——南天门 —— 碧霞祠 —— 玉皇顶&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;本线路虽然省力便捷，但是以牺牲众多景点为代价，建议乘车抵达中天门后，步行登至山顶，以便欣赏更多的泰山美景。&lt;/li&gt;
&lt;li&gt;相对来讲这条路线更适合带小孩或者老人出行的家庭。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;天烛峰-最古朴自然的登山线路&#34;&gt;天烛峰 - 最古朴自然的登山线路&lt;/h3&gt;

&lt;p&gt;此线路以【天烛峰】为起点，位置在泰山东北麓的扫帚峪，长达 5.4 公里。这里奇峰俊秀，松石多姿，自然之美不逊于张家界，天柱峰其峰顶有一颗松树，远望像蜡烛的火焰而得名。此线路是泰山人工开发程度最低的景区，原始朴拙，风貌自然保持完好，是泰山“奥绝”所在。建议喜欢自助游的小伙伴，可以选择本线路下山，这样不仅避免走回头路，而且可以更加全面的欣赏泰山美景。&lt;/p&gt;

&lt;p&gt;该路线途径：天烛峰（进山购票处：125 元/位）——望天门——姊妹松——小天烛峰——娘娘庙——索道（单程 20 元/人）——玉皇顶&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips：
这条路沿途的旅游服务设施相对前两条登山线路略有不足，选择此处上下山需要自备食品和水。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;桃花峪-最浪漫的登山线路&#34;&gt;桃花峪 - 最浪漫的登山线路&lt;/h3&gt;

&lt;p&gt;此线路由以【桃花峪】为起点，位置在泰山西麓。春天桃花盛开的时候，满山遍野尤其俊美。本线路登山位置距离市区较远，仅适合自驾游客选择。不建议普通自由行游客由此登山。&lt;/p&gt;

&lt;p&gt;该路线途径：桃花峪（进山购票处：125 元/位；景区交通车：30 元/位）——钓鱼台——碧峰寺——彩石溪——赤鳞溪——红雨川——桃花源索道（单程 100 元/人）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips：
索道与地面落差巨大，恐高或者有心脏方面疾病的客人，不建议乘坐桃花源索道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;夜爬泰山你需要知道点什么&#34;&gt;夜爬泰山你需要知道点什么&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择登山线路之后，再次需要确认的就是登山时间了。在这里需要简单的提一下泰山的四大奇观：泰山日出、云海玉盘、晚霞夕照、泰山佛光。其中排在泰山四大奇观之首的就是泰山日出。日出时刻的美景动人心弦，也是“天下第一山”的重要标志。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;观赏泰山日出，有两种方式可以选择：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;是住在泰山顶的宾馆，第二天早起直接山顶观看；&lt;/li&gt;
&lt;li&gt;是前半夜开始由【红门】登山，6 小时左右抵达山顶后，略等片刻即可观看到日出。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;两种方式各有利弊，住在山顶的好处是起床后不用过于劳累即可观赏日出，缺点是山顶房间与物资紧张，住宿费用虚高，住宿性价比低，而且在旅游旺季有钱未必有房。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这里推荐半夜登山，红门方向登山的游客数量很多，不必担心安全问题，半山腰可以观看到泰安市夜景，最主要是可以省下好多的银子，缺点就是半夜登山对体力消耗略大，对后几天的生物钟有影响。【红门】登山盘山道是 24 小时开放，另外三条登山线路环山车晚上停止运营。能否看到日出是无法预测的，要视当天山顶的天气情况、云量的多少、能见度高低等诸多因素而定。山顶气温比山下气温低 3 - 6 摄氏度，白天感觉差别不大，夜间山顶会感觉有些寒冷，请参考下方登山装备推荐。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;夜登泰山装备推荐&#34;&gt;夜登泰山装备推荐&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;夜登泰山必备装备之【军大衣】。山下、山顶均有租军大衣的摊位。租金 10 元钱左右一件，附带一个防潮垫。一般租借每件大衣需要缴纳100元的押金，老板会开一个押金收据，归还衣服时出示押金收据条后退还收取的押金费用。尤其是夏天的时候，大家最好到了山顶再租，不要听山下老板的忽悠什么山顶多贵，价格一样的。&lt;/li&gt;
&lt;li&gt;【登山杖】选择性购买即可。登山途中的路边小摊位均有出售，价格视质量而定，山脚下卖的两块钱一根的就可以。&lt;/li&gt;
&lt;li&gt;【手电筒】选择性购买即可，最好自己能带一个。&lt;/li&gt;
&lt;li&gt;由于山顶气温略低，数码产品如相机、手机等拍摄装备等，低温下电池性能下降，需要提前充好电，或者携带备用电源。&lt;/li&gt;
&lt;li&gt;食品携带量不宜过大，增加负重对登山体力有消耗，路边摊位均可购买，价格比山下略贵一些。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;注意点&#34;&gt;注意点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;泰安地区住宿标准对比其他城市略低。&lt;/li&gt;
&lt;li&gt;山东地区绝大部分酒店均不提供一次性洗漱用品，美其名曰低碳环保，实则减少成本支出。无论自由行或者参团的朋友，记得携带好个人洗漱用品。&lt;/li&gt;
&lt;li&gt;山上有50余出卫生间，间隔一般 500 米左右。绿牌卫生间是免费的，红牌的卫生间是个人承包，使用是需要收费的，价格一般是 1 元/位。&lt;/li&gt;
&lt;li&gt;登山时一定要穿着舒适的旅游鞋，游览时遵循“登山不观景，观景不登山”，有些台阶很滑，请务必注意安全。&lt;/li&gt;
&lt;li&gt;如选择泰山拍摄一次成像，一定问清价格以免上当（尽量自备相机）。山顶有些景点拍摄取景需要收费，拍照前要看清楚。&lt;/li&gt;
&lt;li&gt;登山途中注意补充水分：不渴先喝、少喝多饮，也可带些高热量的食品（如牛奶、巧克力等），可帮助恢复体力。切勿采摘野生果实食用或饮用山泉水。&lt;/li&gt;
&lt;li&gt;如果有喜欢的泰山摊位纪念品要买，可以略微讨价还价，不买最好不问。尽量不要随便动摊位的东西，如有损坏，需要赔偿。&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>Web RTC Demo</title>
      <link>https://tosone.cn/post/webrtc/</link>
      <pubDate>Sun, 26 Feb 2017 09:56:03 +0000</pubDate>
      
      <guid>https://tosone.cn/post/webrtc/</guid>
      
        <description>&lt;p&gt;WebRTC 项目的最终目的主要是让 Web 开发者能够基于浏览器轻易快捷开发出丰富的实时多媒体应用，而无需下载安装任何插件，Web 开发者也无需关注多媒体的数字信号处理过程，只需编写简单的 Javascript 程序即可实现。&lt;/p&gt;

&lt;p&gt;{% codeblock package.json lang:json %}
{
  &amp;ldquo;name&amp;rdquo;: &amp;ldquo;WebRTC-demo&amp;rdquo;,
  &amp;ldquo;description&amp;rdquo;: &amp;ldquo;A simple WebRTC demo&amp;rdquo;,
  &amp;ldquo;dependencies&amp;rdquo;: {
    &amp;ldquo;uuid&amp;rdquo;: &amp;ldquo;^3.0.1&amp;rdquo;,
    &amp;ldquo;ws&amp;rdquo;: &amp;ldquo;^2.1.0&amp;rdquo;
  }
}
{% endcodeblock %}&lt;/p&gt;

&lt;p&gt;{% codeblock server.js lang:javascript %}
const http = require(&amp;ldquo;http&amp;rdquo;);
const uuid = require(&amp;ldquo;uuid&amp;rdquo;);
const util = require(&amp;ldquo;util&amp;rdquo;);
const fs = require(&amp;ldquo;fs&amp;rdquo;);
const url = require(&amp;lsquo;url&amp;rsquo;);
const path = require(&amp;lsquo;path&amp;rsquo;);
const WebSocket = require(&amp;lsquo;ws&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;const PORT = 3000; //端口
const dist = &amp;ldquo;./&amp;rdquo;; //根目录
const mine = {
  &amp;ldquo;.css&amp;rdquo;: &amp;ldquo;text/css&amp;rdquo;,
  &amp;ldquo;.html&amp;rdquo;: &amp;ldquo;text/html&amp;rdquo;,
  &amp;ldquo;.ico&amp;rdquo;: &amp;ldquo;image/x-icon&amp;rdquo;,
  &amp;ldquo;.jpeg&amp;rdquo;: &amp;ldquo;image/jpeg&amp;rdquo;,
  &amp;ldquo;.jpg&amp;rdquo;: &amp;ldquo;image/jpeg&amp;rdquo;,
  &amp;ldquo;.gif&amp;rdquo;: &amp;ldquo;image/gif&amp;rdquo;,
  &amp;ldquo;.js&amp;rdquo;: &amp;ldquo;text/javascript&amp;rdquo;,
  &amp;ldquo;.json&amp;rdquo;: &amp;ldquo;application/json&amp;rdquo;,
  &amp;ldquo;.pdf&amp;rdquo;: &amp;ldquo;application/pdf&amp;rdquo;,
  &amp;ldquo;.png&amp;rdquo;: &amp;ldquo;image/png&amp;rdquo;,
  &amp;ldquo;.svg&amp;rdquo;: &amp;ldquo;image/svg+xml&amp;rdquo;,
  &amp;ldquo;.swf&amp;rdquo;: &amp;ldquo;application/x-shockwave-flash&amp;rdquo;,
  &amp;ldquo;.tiff&amp;rdquo;: &amp;ldquo;image/tiff&amp;rdquo;,
  &amp;ldquo;.txt&amp;rdquo;: &amp;ldquo;text/plain&amp;rdquo;,
  &amp;ldquo;.wav&amp;rdquo;: &amp;ldquo;audio/x-wav&amp;rdquo;,
  &amp;ldquo;.wma&amp;rdquo;: &amp;ldquo;audio/x-ms-wma&amp;rdquo;,
  &amp;ldquo;.wmv&amp;rdquo;: &amp;ldquo;video/x-ms-wmv&amp;rdquo;,
  &amp;ldquo;.xml&amp;rdquo;: &amp;ldquo;text/xml&amp;rdquo;,
  &amp;ldquo;.mp3&amp;rdquo;: &amp;ldquo;audio/mpeg&amp;rdquo;,
  &amp;ldquo;.mp4&amp;rdquo;: &amp;ldquo;video/mp4&amp;rdquo;,
  &amp;ldquo;.exe&amp;rdquo;: &amp;ldquo;application/octet-stream&amp;rdquo;,
  &amp;ldquo;.md&amp;rdquo;: &amp;ldquo;text/x-markdown&amp;rdquo;
};
const default_visit_list = [&amp;ldquo;index.html&amp;rdquo;, &amp;ldquo;index.htm&amp;rdquo;, &amp;ldquo;default.html&amp;rdquo;, &amp;ldquo;default.htm&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;let default_visit = (request, response, default_visit_file_list, i) =&amp;gt; {
  fs.exists(path.join(&lt;strong&gt;dirname, dist, url.parse(request.url).pathname, default_visit_file_list[i]), function (exists) {
    if (exists) { //若index.html存在
      fs.readFile(path.join(&lt;/strong&gt;dirname, dist, url.parse(request.url).pathname, default_visit_file_list[i]), &amp;ldquo;binary&amp;rdquo;, function (err, file) {
        response.writeHead(200, {
          &amp;lsquo;Content-Type&amp;rsquo;: mine[&amp;ldquo;.html&amp;rdquo;] || &amp;ldquo;text/plain&amp;rdquo;
        });
        response.write(file, &amp;ldquo;binary&amp;rdquo;);
        response.end();
      });
    } else { //若index.html不存在
      if (default_visit_file_list.length - 1 == i) {
        console.log(&amp;rdquo;\x1B[31mERROR\x1B[39m: &amp;ldquo; + default_visit_file_list[0] + &amp;ldquo; is not exists.&amp;rdquo;);
        file_not_found
          (response, request);
      } else {
        default_visit(request, response, default_visit_list, i + 1);
      }
    }
  });
}
let file_not_found = (response, request) =&amp;gt; {
  response.writeHead(404, {
    &amp;lsquo;Content-Type&amp;rsquo;: &amp;lsquo;text/plain&amp;rsquo;
  });
  response.write(&amp;ldquo;This request URL &amp;rdquo; + url.parse(request.url).pathname + &amp;ldquo; was not found on this server.&amp;rdquo;);
  response.end();
}
let server = http.createServer((request, response) =&amp;gt; {
  let realPath = path.join(__dirname, dist, url.parse(request.url).pathname);
  if (url.parse(request.url).pathname == &amp;ldquo;/&amp;rdquo; || url.parse(request.url).pathname.split(&amp;ldquo;/&amp;rdquo;)[url.parse(request.url).pathname.split(&amp;ldquo;/&amp;rdquo;).length - 1].indexOf(&amp;ldquo;.&amp;rdquo;) == -1) { //访问目录为 &amp;ldquo;/&amp;rdquo;
    default_visit(request, response, default_visit_list, 0);
  } else { //指定路径
    let ext = path.extname(realPath);
    fs.exists(realPath, exists =&amp;gt; {
      if (!exists) { //指定路径的文件不存在
        console.log(&amp;rdquo;\x1B[31mERROR\x1B[39m: &amp;ldquo; + realPath + &amp;rdquo; is not exists.&amp;ldquo;);
        file_not_found(response, request);
      } else { //指定路径的文件存在
        fs.readFile(realPath, &amp;ldquo;binary&amp;rdquo;, (err, file) =&amp;gt; {
          response.writeHead(200, {
            &amp;lsquo;Content-Type&amp;rsquo;: mine[ext] || &amp;ldquo;text/plain&amp;rdquo;
          });
          response.write(file, &amp;ldquo;binary&amp;rdquo;);
          response.end();
        });
      }
    });
  }
});
server.listen(PORT);
server.on(&amp;lsquo;listening&amp;rsquo;, () =&amp;gt; {
  console.log(&amp;ldquo;Server runing at &lt;a href=&#34;http://127.0.0.1:&amp;quot;&#34;&gt;http://127.0.0.1:&amp;quot;&lt;/a&gt; + server.address().port + &amp;ldquo;.&amp;rdquo;);
});
server.on(&amp;lsquo;error&amp;rsquo;, () =&amp;gt; {
  console.log(&amp;ldquo;Server Listen on &amp;rdquo; + PORT + &amp;ldquo; error.&amp;rdquo;);
});
let sockets = new Map();
let socketsID = new Set();
let wss = new WebSocket.Server({ server: server });
wss.on(&amp;lsquo;connection&amp;rsquo;, socket =&amp;gt; {
  socket.id = uuid.v4().split(&amp;ldquo;-&amp;rdquo;).join(&amp;ldquo;);
  console.log(&amp;lsquo;connection &amp;rsquo; + sockets.size);
  socket.send(JSON.stringify({
    event: &amp;ldquo;peers&amp;rdquo;,
    data: {
      queue: sockets.size + 1,
      socketID: socket.id,
      socketsID: Array.from(socketsID)
    }
  }));
  for (let item of sockets.entries()) {
    item[1].send(JSON.stringify({
      event: &amp;ldquo;new_peer&amp;rdquo;,
      data: {
        socketID: socket.id,
        me: item[1].id
      }
    }));
  }
  sockets.set(socket.id, socket);
  socketsID.add(socket.id);
  socket.on(&amp;lsquo;message&amp;rsquo;, msg =&amp;gt; {
    console.log(JSON.parse(msg).event + &amp;ldquo;: &amp;ldquo; + socket.id + &amp;rdquo; &amp;mdash;&amp;gt; &amp;ldquo; + sockets.get(JSON.parse(msg).data.socketID).id);
    if (JSON.parse(msg).event === &amp;ldquo;msg&amp;rdquo;) {
      for (let item of sockets.entries()) {
        if (item[0] == JSON.parse(msg).data.socketID) continue;
        item[1].send(msg);
      }
    } else {
      sockets.get(JSON.parse(msg).data.socketID).send(msg);
    }
  });
  socket.on(&amp;ldquo;close&amp;rdquo;, () =&amp;gt; {
    console.log(&amp;ldquo;delete &amp;rdquo; + socket.id);
    sockets.delete(socket.id);
    socketsID.delete(socket.id);
    for (let item of sockets.entries()) {
      item[1].send(JSON.stringify({
        event: &amp;ldquo;close&amp;rdquo;,
        data: {
          socketID: socket.id
        }
      }));
    }
  })
});
{% endcodeblock %}
{% codeblock index.html lang:html %}
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&#34;UTF-8&#34;&gt;
  &lt;style&gt;
    html,
    body {
      margin: 0;
      padding: 0;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;body {
  font-size: 62.5%;
  font-family: Consolas, &amp;quot;Microsoft Yahei&amp;quot;;
  height: 100%;
  width: 100%;
  background: url(https://o3cpfaosb.qnssl.com/4874bd3e3bb8e89fd704771c77551f70.png) center center no-repeat;
  background-size: 100% 100%;
  background-attachment: fixed;
}

.login {
  display: block;
  font-family: inherit;
  left: 50%;
  top: 50%;
  line-height: 1;
  width: 400px;
  height: 40px;
  position: absolute;
  margin-left: -200px;
  margin-top: -20px;
  box-sizing: border-box;
  border: 1px solid #333;
  font-size: 2rem;
  padding: 3px;
  border-radius: 5px;
}

.login:focus,
.login:active {
  border: 1px solid #333;
}

.body {
  width: 960px;
  margin: 0 auto;
}

.box {
  width: 100%;
}

video {
  float: left;
  width: 420px;
  height: 315px;
  margin: 30px;
  background-color: #333;
  border-radius: 4px;
  width: 420px;
  height: 315px;
  border-radius: 4px;
}

.message {
  background-color: #333;
  height: 400px;
  width: 900px;
  margin: 0 auto;
  padding: 3px 10px;
  line-height: 1.2;
  overflow-y: auto;
  overflow-x: visible;
  box-sizing: border-box;
}

 ::-webkit-scrollbar {
  width: 5px;
  background-color: transparent;
}

 ::-webkit-scrollbar-track {
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);
  border-radius: 10px;
  background-color: #777;
}

 ::-webkit-scrollbar-thumb {
  height: 20px;
  border-radius: 10px;
  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);
  background-color: #555;
}

p {
  margin: 0;
}

p .name {
  font-size: 2rem;
}

p .name.me {
  color: #12BCD4;
}

p .name.other {
  color: #F34E4E;
}

p .msg {
  font-size: 1.8rem;
  color: #A9A7A7;
  word-wrap: break-word;
}

#msg-ipt {
  display: block;
  margin-left: 30px;
  margin-right: 30px;
  width: 900px;
  box-sizing: border-box;
  height: 40px;
  line-height: 40px;
  font-size: 2rem;
  margin-top: 10px;
  border-radius: 5px;
  border: 0;
  padding: 3px;
}

#msg-ipt:active {
  outline: none;
  border: 0;
}

.clearfix:after {
  content: &amp;quot;.&amp;quot;;
  display: block;
  height: 0;
  clear: both;
  visibility: hidden
}

.clearfix {
  *+height: 1%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&#34;body&#34;&gt;
    &lt;div class=&#34;box clearfix&#34;&gt;
      &lt;video id=&#34;localVideo&#34; autoplay&gt;&lt;/video&gt;
    &lt;/div&gt;
    &lt;div class=&#34;message&#34;&gt;&lt;/div&gt;
    &lt;input type=&#34;text&#34; id=&#34;msg-ipt&#34;&gt;
  &lt;/div&gt;
  &lt;script src=&#34;https://cdn.bootcss.com/jquery/2.2.1/jquery.min.js&#34;&gt;&lt;/script&gt;
  &lt;script src=&#39;index.js&#39;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
{% endcodeblock %}
{% codeblock index.js lang:javascript %}
var iceServer = {
  &amp;ldquo;iceServers&amp;rdquo;: [{
    url: &amp;ldquo;stun:115.28.87.181:40167&amp;rdquo;
  }]
};
var socket = new WebSocket(&amp;ldquo;wss://&amp;rdquo; + window.location.host); //socket
var localStream = null;
var peerconns = new Map();
var ipt_addevent = false;
socket.onopen = function () {
  socket.onmessage = function (msg) {
    new Promise(function (resolve, reject) {
      if (localStream) {
        resolve(localStream);
      } else {
        navigator.webkitGetUserMedia({
          &amp;ldquo;audio&amp;rdquo;: true,
          &amp;ldquo;video&amp;rdquo;: true
        }, function (stream) {
          localStream = stream;
          resolve(stream);
          document.getElementById(&amp;lsquo;localVideo&amp;rsquo;).src = URL.createObjectURL(stream);
        }, function (error) {
          reject(error);
        });
      }
    }).then(function (stream) {
      var json = JSON.parse(msg.data);
      var data = json.data;
      if (!ipt_addevent) {
        ipt_addevent = true;
        var ipt = document.getElementById(&amp;ldquo;msg-ipt&amp;rdquo;);
        ipt.addEventListener(&amp;ldquo;keydown&amp;rdquo;, function (e) {
          if (e.keyCode == 13) {
            socket.send(JSON.stringify({
              event: &amp;ldquo;msg&amp;rdquo;,
              data: {
                msg: ipt.value,
                socketID: data.socketID
              }
            }));
            $(&amp;ldquo;.message&amp;rdquo;).append(&amp;rdquo;&lt;p&gt;&lt;span class=\&#34;name me\&#34;&gt;&amp;rdquo; + data.socketID + &amp;ldquo;: &lt;/span&gt;&lt;span class=\&#34;msg\&#34;&gt;&amp;rdquo; + ipt.value + &amp;ldquo;&lt;/span&gt;&lt;/p&gt;&amp;rdquo;);
            ipt.value = &amp;ldquo;&amp;rdquo;;
          }
        }, true);
      }
      var createRTCPeerConnection = function (socketID, me) {
        var pc = new webkitRTCPeerConnection(iceServer);
        pc.addStream(stream);
        peerconns.set(socketID, pc);
        pc.onicecandidate = function (event) {
          if (event.candidate !== null) {
            socket.send(JSON.stringify({
              event: &amp;ldquo;_ice_candidate&amp;rdquo;,
              data: {
                candidate: event.candidate,
                socketID: socketID,
                me: me
              }
            }));
          }
        };
        pc.onaddstream = function (event) {
          $(&amp;ldquo;.box&amp;rdquo;).append(&amp;rdquo;&lt;video id=\&#34;&#34; + socketID + &#34;\&#34; autoplay src=&#39;&#34; + URL.createObjectURL(event.stream) + &#34;&#39;&gt;&lt;/video&gt;&amp;rdquo;)
        };
        return pc;
      }
      switch (json.event) {
      case &amp;ldquo;new_peer&amp;rdquo;:
        console.log(data.me)
        createRTCPeerConnection(data.me, data.socketID);
        break;
      case &amp;lsquo;peers&amp;rsquo;:
        console.log(data.socketsID)
        for (var i in data.socketsID) {
          (function () {
            var otherSocketID = data.socketsID[i];
            console.log(otherSocketID)
            var pc = createRTCPeerConnection(otherSocketID, data.socketID);
            pc.createOffer(function (desc) {
              pc.setLocalDescription(desc);
              socket.send(JSON.stringify({
                event: &amp;ldquo;_offer&amp;rdquo;,
                data: {
                  sdp: desc,
                  socketID: otherSocketID,
                  me: data.socketID
                }
              }));
            }, function (error) {
              console.log(&amp;lsquo;Failure callback: &amp;lsquo; + error);
            });
          })()
        }
        if (data.queue == 1) {
        }
        break;
      case &amp;lsquo;_ice_candidate&amp;rsquo;:
        var pc = peerconns.get(data.socketID);
        pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        break;
      case &amp;lsquo;_offer&amp;rsquo;:
        var pc = peerconns.get(data.socketID);
        pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        pc.createAnswer(function (desc) {
          pc.setLocalDescription(desc);
          socket.send(JSON.stringify({
            event: &amp;ldquo;_answer&amp;rdquo;,
            data: {
              sdp: desc,
              socketID: data.me,
              me: data.socketID
            }
          }));
        }, function (error) {
          console.log(&amp;lsquo;Failure callback: &amp;lsquo; + error);
        });
        break;
      case &amp;lsquo;_answer&amp;rsquo;:
        peerconns.get(data.me).setRemoteDescription(new RTCSessionDescription(data.sdp)); //receive answer
        break;
      case &amp;ldquo;close&amp;rdquo;:
        peerconns.delete(data.socketID);
        $(&amp;ldquo;#&amp;rdquo; + data.socketID).remove();
        break;
      case &amp;ldquo;msg&amp;rdquo;:
        $(&amp;ldquo;.message&amp;rdquo;).append(&amp;rdquo;&lt;p&gt;&lt;span class=\&#34;name other\&#34;&gt;&amp;rdquo; + data.socketID + &amp;ldquo;: &lt;/span&gt;&lt;span class=\&#34;msg\&#34;&gt;&amp;rdquo; + data.msg + &amp;ldquo;&lt;/span&gt;&lt;/p&gt;&amp;rdquo;);
        break;
      }
    }).catch(function (err) {
      console.log(err);
    });
  }
}
{% endcodeblock %}&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>N 阶行列式求解</title>
      <link>https://tosone.cn/post/matrix-calc/</link>
      <pubDate>Fri, 24 Feb 2017 22:09:45 +0000</pubDate>
      
      <guid>https://tosone.cn/post/matrix-calc/</guid>
      
        <description>&lt;p&gt;用递归的方式求解 N 阶行列式的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;malloc.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt; // 包含的头文件不解释
typedef bool int    // 因为标准c里边没有bool类型才这么做

#define false 0

#define true 1
    int *c,   // 将整个行列式的值存到c指向的空间里
    n = 0,    // 记录当前的行列式计算进行了多少步
    a,        // 方便传递行列式的阶数
    sum = 0;  // 记录每一步行列式计算所累加的结果

// 计算阶乘的函数
int aq(int a) {
  int s = 1;
  for (int i = 1; i &amp;lt;= a; i++)
    s *= i;
  return s;
}

void swap(int *a, int *b) {
  int m = *a;
  *a = *b;
  *b = m;
}

// 计算在行列式计算过程中每一项前边的符号是正还是负
bool sa(int *l) {
  int n = 0; // n为行列式展开式每一项的逆序数
  for (int i = 0; i &amp;lt; a - 1; i++)
    for (int j = i + 1; j &amp;lt; a; j++)
      if (l[i] &amp;gt; l[j])
        n++; // 不断通过条件判断累加逆序数得出最终的逆序数
  if (n % 2 == 0)
    return false; // 若为正，则返回false
  return true;    // 否则返回true
}

// 整个程序里边的核心函数，找出在不同行不同列的所有组合
void perm(int *l, int k, int m) {
  int i, s = 1;
  if (k &amp;gt; m) {
    n++; // 每递归回来一次，将记录运行次数加一
    for (int j = 0; j &amp;lt; a; j++)
      s *= c[l[j] + a * j]; // 算出此次行列式展开式的这项的值
    if (sa(l))
      s * = -1; // 确定这一项的符号
    // 输出当前sum内的值（即到当前为止所得到的结果是多少）
    // 输出运行的完成程度（即当前运行的次数除以总次数）
    printf(&amp;quot;%5d      完成度：%2.2f%%\n&amp;quot;, sum + = s, n / (aq(a) * 0.1) * 10);
  } else {
    for (i = k; i &amp;lt;= m; i++) {
      swap(l + k, l + i);
      perm(l, k + 1, m);
      swap(l + k, l + i);
    }
  }
}

void main()
{
  int *
      b,              // 一个辅助变量，在递归函数中将b指向的空间内的值进行全排列，也即行列式展开式不同组合的下标
      i,              // 循环中的辅助变量
      f,              // 在格式化输出行列式的辅助变量
      e;              // 判断是否退出程序的标志位
  system(&amp;quot;color 3e&amp;quot;); // 设置程序运行的前景色和背景色
u:
  system(&amp;quot;cls&amp;quot;); // 清空屏幕
  printf(&amp;quot;请输入行列式的阶数：\n&amp;quot;);
  scanf(&amp;quot;%d&amp;quot;, &amp;amp;a);                    // 获取行列式的阶数
  b = (int *)malloc(sizeof(int) * a); // 为变量申请空间
  c = (int *)malloc(sizeof(int) * a * a);
  for (i = 0; i &amp;lt; a; i++)
    *(b + i) = i; // 为辅助变量也即行列式下标逐个赋值
  for (i = 0; i &amp;lt; a * a; i++) {
    if (i % a == 0)
      printf(&amp;quot;请依次输入行列式中第%d行的值（以空格分隔）：\n&amp;quot;,
             i / a + 1); // 提示输入行列式的值
    scanf(&amp;quot;%d&amp;quot;, c + i);
  }
  printf(&amp;quot;\n\n&amp;quot;);
  perm(b, 0, a - 1);                         // 计算行列式的值
  printf(&amp;quot;\n行列式展开式共有%d项\n&amp;quot;, aq(a)); // 打印出来行列式的各种信息
  if (a % 2 != 0)
    f = a + 1; // 判断当前的行列式是偶数行还是奇数行
  else
    f = a;
  for (i = 0; i &amp;lt; a * a; i++) {
    if (i / a + 1 == f / 2 &amp;amp;&amp;amp; i % a == 0) // 判断是否达到行列式中间的一行行首
      printf(&amp;quot;D = &amp;quot;);                     // 输出“D = ”
    else if (i % a ==
             0) // 判断是否是每一行的行首，若是则输出四个空格，保证输出的格式优美
      printf(&amp;quot;    &amp;quot;);
    if (i % a == 0) // 判断是否是行首，若是输出制表符竖线，可与上一句写到一块儿
      printf(&amp;quot;┃&amp;quot;);
    if ((i + 1) % a == 0) // 判断是否是行列式某一行的最后一个数
      printf(&amp;quot;%2d&amp;quot;, *(c + i));
    else
      printf(&amp;quot;%2d &amp;quot;,
             *(c + i)); // 若不是行列式某一行的最后一个数则在数字后边加一个空格
    if ((i + 1) % a == 0) // 判断是否到达一行的行末
      printf(&amp;quot;┃&amp;quot;);
    if ((i + 1) / a == f / 2 &amp;amp;&amp;amp;
        (i + 1) % a == 0) // 判断是否达到行列式中间一行的行末，输出整个行列式的值
      printf(&amp;quot; = %d\n&amp;quot;, sum);
    else if ((i + 1) % a == 0) // 判断是否到达行末输出换行
      printf(&amp;quot;\n&amp;quot;);
  }
  printf(&amp;quot;\n\n&amp;quot;);
  printf(&amp;quot;是否继续？（ 1 / 0 ）\n&amp;quot;); // 提示是否退出
  scanf(&amp;quot;%d&amp;quot;, &amp;amp;e);
  n = 0; // 每次都将都将上一次的运行记录消除
  if (e == 1)
    goto u; // 判断是否推出
  else if (e == 0)
    exit(0);
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>
